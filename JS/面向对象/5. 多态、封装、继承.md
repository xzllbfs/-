面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式。它使用先前建立的范例，包括模块化，多态和封装几种技术。任何一个对象都是唯一的，这与它本身的状态无关。我们用状态来描述对象，状态的改变即是行为。

# 多态

描述动态性的程度

# 封装

 封装，复用，解耦，内聚（描述架构）

# 继承

Class Base 面向对象

## 原型继承

原型继承是 JavaScript 构造对象系统的标准方法。在 ES6 之前，这一方法是继承模型唯一的选择，它既是这门语言的核心精髓，也是主要的设计负担。

### 实质

修改原型是 JavaScript 中最常用的构建对象系统的方法，它的好处是可以在实例构造之后，动态地响这些实例。也就是说，对象实例的特性不但可以通过 new 运算符构造出来，也可以通过**原型修改**来持续获得。

原型继承的实质就是**对原型修改效果的传递**，它基于原型链的特性：访问属性时，如果子对象没有该属性，则将访问其原型的属性类。实际上，**所有继承方式的本质都是原型链**。

**简单模型**

用来讲述原型继承的一个比较学术型的示例，是做一个动物王国的模型。无论有多么伟大的构想，我们也得从一只猫和一只狗开始。

```js
// 构造器
function Animal() {} // 动物
function Mammal() {} // 哺乳类
function Canine() {} // 犬科
function Dog() {} // 狗
function Cat() {} // 猫


// 原型链表(关系链)
Mammal.prototype = new Animal()
Canine.prototype = new Mammal()
Dog.prototype = new Canine()
Cat.prototype = new Mammal()

function isAnimal(obj) {
  return obj instanceof Animal
}

var dog = new Dog()
var cat = new Cat()

// 测试(是动物吗？)
console.log(isAnimal(dog)) // true

// 原型修改-让动物拥有呼吸特性
Animal.prototype.respire = function() {
  console.log('交换氧气与二氧化碳')
}

// 检查属性—猫和狗都有呼吸了
console.log('respire' in dog)
console.log('respire' in cat)
```

上面的例子中，我们写了一个函数`isAnimal()`来证明狗是一种动物。然后我们通过该修改原型的方式加了一种特性—呼吸，这样继承下来的实例就都拥有这种特性了。对于这个实例来说，该继承的树形如图：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce8f2080229c4761a7c77328f57eac98~tplv-k3u1fbpfcp-watermark.image)

注意，在构造这个继承树时，狗属于犬科这个分支，而猫是属于哺乳类这个分支的。这意味着犬科的原型修改不会影响猫，而哺乳类的原型修改会影响到猫。

### 缺点

原型继承是一个典型的以时间换空间的解决方案：继承层次中临近的成员访问更快，而试图访问一个不存在的成员耗时最久。

对于原型继承来说，它存在一些语言特性上的缺陷：

1. 在维护构造器引用和外部原型链之间无法平衡
2. 没有提供调用父类方法的机制。

其根本原因是：JavaScript 原本就是为了一种轻量级的、嵌入式的、以Web 浏览器端为主的脚本语言而设计的，这种应用环境决定了它的空间占用是关键，而时间消耗则相对次要得多。

## 类继承

原型继承依赖程序的执行过程，是通过原型修改来实现继承特性的一种方法。在这种情况下，子类构造器的声明一定晚于父类构造器。

```js
function Parent() {}
function Child() {}
Child.prototype = new Parent()
```

类继承是通过**声明语法**来将代码中的构造器声明和继承关系声明全部提前到了语法解析阶段。

```
class child extends Parent{}
class Parent {}
class child {}
```

类的本质就是在描述对象，其 extends 声明，则是在描述继承关系。`child`被声明出来之后，`child.prototype`的内部原型链就会被置为 `Parent.prototype`。

类的实例时创建自基类的，类构造方法的调用顺序是逆向的。**类继承既是对原型继承的增强，也是一种再实现**。

### 缺点

类继承比原型继承更加强调设计过程，类是对象的描述者，并且这种描述是强加在考虑好某个类是否具有某属性、方法或其他特征。如果某个类的成员设计得不正确，则它的子类、接口及实例等在使用过程中都将遇到问题。而重构这样的系统的代价是高昂的。

## 如何选择继承方式

