# 模块化开发

模块化是当下最主流的开发范式之一。随着前端应用的日益复杂，项目代码已经逐渐膨胀到了不得不花大量时间去管理的程度，模块化是一种主流的代码组织方式。
通过将负责代码按照功能的不同划分为不同的模块单独维护的方式，提高开发效率，降低维护成本。「模块化」只是一种思想，并不包含具体的实现

## 模块化演变过程
1. 第一阶段：基于文件的划分模块的方式
- 具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）。
- 缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系，完全依靠约定。
```html
<script src="module-a.js"></script>
<script src="module-b.js"></script>
<script>
  // 命名冲突
  method1()
  // 模块成员可以被修改
  name = 'foo'
</script>
```
```js
// module a 相关状态数据和功能函数
var name = 'module-a'

function method1 () {
  console.log(name + '#method1')
}

function method2 () {
  console.log(name + '#method2')
}

// module b 相关状态数据和功能函数
var name = 'module-b'

function method1 () {
  console.log(name + '#method1')
}

function method2 () {
  console.log(name + '#method2')
}
```
2. 第二阶段：命名空间方式   —  每个模块只暴露一个全局对象，所有模块成员都挂载到这个对象中
- 具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。
- 缺点：通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。
```html
<script src="module-a.js"></script>
<script src="module-b.js"></script>
<script>
  moduleA.method1()
  moduleB.method1()
  // 模块成员可以被修改
  moduleA.name = 'foo'
</script>
```
```js
// module a 相关状态数据和功能函数
var moduleA = {
  name: 'module-a',

  method1: function () {
    console.log(this.name + '#method1')
  },

  method2: function () {
    console.log(this.name + '#method2')
  }
}

// module b 相关状态数据和功能函数
var moduleB = {
  name: 'module-b',

  method1: function () {
    console.log(this.name + '#method1')
  },

  method2: function () {
    console.log(this.name + '#method2')
  }
}
```
3. 第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间
- 具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现
- 缺点：有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。
```html
<script src="module-a.js"></script>
<script src="module-b.js"></script>
<script>
  moduleA.method1()
  moduleB.method1()
  // 模块私有成员无法访问
  console.log(moduleA.name) // => undefined
</script>
```
```js
// module a 相关状态数据和功能函数
;(function () {
  var name = 'module-a'
  
  function method1 () {
    console.log(name + '#method1')
  }
  
  function method2 () {
    console.log(name + '#method2')
  }

  window.moduleA = {
    method1: method1,
    method2: method2
  }
})()
```
```js
// module b 相关状态数据和功能函数
;(function () {
  var name = 'module-b'
  
  function method1 () {
    console.log(name + '#method1')
  }
  
  function method2 () {
    console.log(name + '#method2')
  }

  window.moduleB = {
    method1: method1,
    method2: method2
  }
})()
```

4. 第四阶段：利用 IIFE 参数作为依赖声明使用
- 具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。
- 缺点：这使得每一个模块之间的关系变得更加明显。
```html
<script src="https://unpkg.com/jquery"></script>
<script src="module-a.js"></script>
<script src="module-b.js"></script>
<script>
  moduleA.method1()
  moduleB.method1()
</script>
```
```js
// module a 相关状态数据和功能函数
;(function ($) {
  var name = 'module-a'
  
  function method1 () {
    console.log(name + '#method1')
    $('body').animate({ margin: '200px' })
  }
  
  function method2 () {
    console.log(name + '#method2')
  }

  window.moduleA = {
    method1: method1,
    method2: method2
  }
})(jQuery)
```

## 模块化规范
### CommonJS规范
- 特点： 一个文件就是一个模块，每个模块都有单独的作用域，通过module.exports导出成员，通过require函数载入模块
- 缺点：CommonJS是Nodejs提出的规范，以**同步模式**加载模块，在浏览器端，每次页面加载都会有大量的异步请求出现，同步模式会导致效率低下，所以在早起前端规范中没有被采用。而Node的执行机制是在启动时加载模块，执行过程中不需要加载，所以CommonJS更适合Nodejs使用。

### AMD规范
Asynchronous Module Definition 异步的定义规范，同期推出了Require.js，实现了AMD规范，是一个非常强大的模块加载器，目前绝大多数的第三方库都支持AMD规范。
- 缺点：使用起来相对复杂，模块划分细致时模块JS文件请求频繁
```js
// 因为 jQuery 中定义的是一个名为 jquery 的 AMD 模块
// 所以使用时必须通过 'jquery' 这个名称获取这个模块
// 但是 jQuery.js 并不在同级目录下，所以需要指定路径
define('module1', ['jquery', './module2'], function ($, module2) {
  return {
    start: function () {
      $('body').animate({ margin: '200px' })
      module2()
    }
  }
})
```

### Sea.js + CMD规范
Common Module Definition 通用的模块定义规范。写法类似于CommoJS，使用上也可以通过Require.js来实现。
```js
// 兼容 CMD 规范（类似 CommonJS 规范）
define(function (require, exports, module) {
	// 通过 require 引入依赖
  var $ = require('jquery')
  // 通过 exports 或者 module.exports 对外暴露成员
  module.exports = function () {
    console.log('module 2~')
    $('body').append('<p>module2</p>')
  }
})
```

### ES Modules规范
目前的模块规范在Node端统一用CommonJS规范，在浏览器端统一用ES Modules规范，是在ECMAScript中定义的一套最新的模块系统，存在各种环境的兼容问题。后来随着webpack等打包工具的普及，规范才逐渐开始普及。

#### 基本特性
1. 自动采用严格模式，忽略'use strict'
```html
<script type="module">
  console.log(this) // undefined  模块中获取不到全局的this
</script>
```
2. 每个ESM模块都是单独的私有作用域
```html
<script type="module">
  var foo = 100
  console.log(foo)
</script>
<script type="module">
  console.log(foo) // undefined
</script>
```
3. ESM是通过CORS去请求外部JS模块的
```html
<script type="module" src="https://unpkg.com/jquery@3.4.1/dist/jquery.min.js"></script>
```
4. ESM的script标签会延迟执行脚本
```html
<script defer src="demo.js"></script>
<p>需要显示的内容</p>
```

#### 模块导入导出
##### 基本使用
- 导入
```js
// import { default as fooName } from './module.js'
// console.log(fooName)

import { name, hello, Person } from './module.js'
console.log(name, hello, Person)
```

##### 注意事项
- 批量导出的不是一个对象，ES Module 中 { } 是固定语法，就是直接提取模块导出成员
```js
var name = 'jack'
var age = 18

export { name, age } // 导出的不是一个对象

var obj = { name, age }
export { name, age } // 错误写法
export default { name, age } // 正确写法
```
```js
// CommonJS 中是先将模块整体导入为一个对象，然后从对象中结构出需要的成员
// const { name, age } = require('./module.js')

// ES Module 中 { } 是固定语法，就是直接提取模块导出成员
import { name, age } from './module.js'

console.log(name, age)
```
- 导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export 导入的变量在内存中是同一块空间。一旦模块中成员修改了，这里也会同时修改。
```js
// 导出
var name = 'jack'
var age = 18

export { name, age }

setTimeout(function () {
  name = 'ben'
}, 1000)

```
```js
// 导入
import { name, age } from './module.js'

console.log(name, age)

setTimeout(function () {
  console.log(name, age) // ben 18
}, 1500)

// 导入模块成员变量是只读的
name = 'tom' // 报错

// 但是需要注意如果导入的是一个object，对象的属性读写不受影响
name.xxx = 'xxx' // 正常
```

##### 其它用法
```js
// 不能使用.js扩展名
import { name } from './module' // ./module.js

// 可以通过载入目录方式载入目录下的index.js
import { name } from './utils' // ./utils/index.js

// 相对路径的./不能省略
import { name } from './module' // module

// 可以使用/开头的绝对路径
import { name } from '/04-import/module.js'

// 可以使用完整的url导入
import { name } from 'http://localhost:3000/04-import/module.js'

// 直接执行导出内容,加载模块并不提取
import {} from './module.js'
import './module.js'

// 导出全部成员
import * as mod from './module.js'
console.log(mod)

// 导入路径不能是一个变量
var modulePath = './module.js'
import { name } from modulePath
console.log(name)

if (true) {
  import { name } from './module.js'
}

// 动态导入模块
import('./module.js').then(function (module) {
  console.log(module)
})

// 同时导出命名成员和默认成员
// import { name, age, default as title } from './module.js'
import title, { name, age } from './module.js' // 简写
console.log(name, age, title)

// 导出导入成员-一般用于统一导出文件夹所有子模块的成员
export { foo, bar } from './module.js'
```

#### 兼容浏览器
##### polyfill垫片
- 将浏览器不识别的es6模块交给babel转换
- 对于需要外部导入的代码，通过ajax请求文件返回的代码再次转换
- 对于已经支持es6的浏览器，通过添加nomodule属性的方式减少多次请求
```html
<!-- 兼容promise的垫片 -->
<script nomodule src="https://unpkg.com/promise-polyfill@8.1.3/dist/polyfill.min.js"></script>
<!-- 通过es module将代码读出来，然后交给babel转换 -->
<script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js"></script>
<script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js"></script>
<script type="module">
  import { foo } from './module.js'
  console.log(foo)
</script>
```

##### 在Node中使用ES Modules
1. 在nodejs v8.5+版本之后，支持es特性
- 将文件的扩展名由 .js 改为 .mjs
- 启动时需要额外添加 `--experimental-modules` 参数
  
  > node --experimental-modules index.mjs
```js
import { foo, bar } from './module.mjs'

console.log(foo, bar)

// 此时我们也可以通过 esm 加载内置模块了
import fs from 'fs'
fs.writeFileSync('./foo.txt', 'es module working')

// 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员方式
import { writeFileSync } from 'fs'
writeFileSync('./bar.txt', 'es module working')

// 对于第三方的 NPM 模块也可以通过 esm 加载
import _ from 'lodash'
_.camelCase('ES Module')

// 不支持，因为第三方模块都是导出默认成员
// import { camelCase } from 'lodash'
// console.log(camelCase('ES Module'))
```
2. Nodejs最新版本支持ES
- 不用再添加mjs扩展名的js文件，而是将package.json中添加一个type: 'module'的属性
- 对于CommonJS模块的文件扩展名改为.cjs


##### ES Modules 与CommonJS
1. 与CommonJS相互导入导出
- ES模块中可以导入CommonJS模块
- CommonJS中不能导入ES模块
- CommonJS始终只会导出一个默认成员
- 注意import不是解构导出对象

ES Module模块
```js
// ES Module 中可以导入 CommonJS 模块
import mod from './commonjs.js'
console.log(mod)

// 不能直接提取成员，注意 import 不是解构导出对象
import { foo } from './commonjs.js'
console.log(foo)

export const foo = 'es module export value'
```

CommonJS模块
```js
// CommonJS 模块始终只会导出一个默认成员
module.exports = {
  foo: 'commonjs exports value'
}

exports.foo = 'commonjs exports value'

// 不能在 CommonJS 模块中通过 require 载入 ES Module
const mod = require('./es-module.mjs')
console.log(mod)
```

2. 与CommonJS的差异

  CommonJS
```js
// 加载模块函数
console.log(require)

// 模块对象
console.log(module)

// 导出对象别名
console.log(exports)

// 当前文件的绝对路径
console.log(__filename)

// 当前文件所在目录
console.log(__dirname)
```
ES Module 没有CommonJS中的一些模块全局成员
```js
// 1. require, module, exports 自然是通过 import 和 export 代替

// 2. __filename 和 __dirname 通过 import 对象的 meta 属性获取
const currentUrl = import.meta.url
console.log(currentUrl)

// 3. 通过 url 模块的 fileURLToPath 方法转换为路径
import { fileURLToPath } from 'url'
import { dirname } from 'path'
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
console.log(__filename)
console.log(__dirname)
```

##### Babel兼容
对于早期的 Node.js 版本，可以使用 Babel 实现 ES Module 的兼容
```shell
yarn add @babel/node @babel/core @babel/preset-env --dev

# 转换js
yarn babel-node index.js

# 转换commonjs的插件
yarn add @babel/plugin-transform-modules-commonjs --dev
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed4e096b4f3d45aea8ceba15552ce4b4~tplv-k3u1fbpfcp-watermark.image)
.babelrc
```json
{
  "presets": ["@babel/preset-env"],
  "plugins": [
    "@babel/plugin-transform-modules-commonjs"
  ]
}
```

## 模块化打包工具
现有的模块化系统，ES Modules存在环境兼容问题，模块文件过多会导致网络请求频繁，而除了js之外的其它前端资源都需要模块化，毋庸置疑，模块化是必要的。它的作用包括，新特性代码编译，模块化JS打包，支持不同种类的资源模块等功能。

### Webpack
- 模块打包器将零散的代码打包到同一个文件中，对于环境中有兼容问题的代码，通过模块加载器（loader）对其进行编译转换；
- 同时局部代码拆分（Code Splitting）拆分的能力，将应用的中代码按照需求打包，渐进式加载；避免文件过大占用空间的问题
- 以模块化的方式载入任意种类的资源模块（Asset Module）

#### 一、加载资源的方式
1. 不同模块化规范的导入导出
- 遵循ES Modules 标准的import声明
```js
import createHeading from './heading.js'
import better from './better.png'
import './main.css'

const heading = createHeading()
const img = new Image()
img.src = better
document.body.append(heading)
document.body.append(img)
```
- 遵循CommonJs标准的require函数
```js
const createHeading = require('./heading.js').default
const better = require('./better.png')
require('./main.css')

const heading = createHeading()
const img = new Image()
img.src = better
document.body.append(heading)
document.body.append(img)
```
- 遵循AMD标准的define函数和require函数
```js
define(['./heading.js', './better.png', './main.css'], (createHeading, better) => {
  const heading = createHeading.default()
  const img = new Image()
  img.src = better
  document.body.append(heading)
  document.body.append(img)
})

require(['./heading.js', './better.png', './main.css'], (createHeading, better) => {
  const heading = createHeading.default()
  const img = new Image()
  img.src = better
  document.body.append(heading)
  document.body.append(img)
})
```
2. Loader加载的非Javascript也会触发资源加载
- 样式代码中的@import 指令和url函数
```css
@import url(reset.css);
/*css-loader 同样支持 sass/less 风格的 @import 指令*/
/*@import 'reset.css';*/

body {
  min-height: 100vh;
  background: #f4f8fb;
  background-image: url(background.png);
  background-size: cover;
}
```
- HTML代码中图片标签的src属性
```js
import './main.css'

import footerHtml from './footer.html'

document.write(footerHtml)
```

#### 二、核心工作原理
在项目中散落了很多代码及资源文件，webpack根据配置**找到其中的一个资源文件作为打包入口**（一般为js文件）；然后解析入口文件中的代码，根据代码中出现的import,require之类的语句，推断出来这个文件所依赖的资源模块，分别**解析每一个资源模块对应的依赖**，最后**形成**了拥有所有资源文件中的依赖关系的**依赖树**；webpack**递归依赖关系树**，找到每个节点对应的资源文件，然后根据配置文件中模块的rules属性，找到对应的模块加载器去**加载对应的模块**，最后将加载的结果放在打包结果文件buldle.js中，其中loader机制是webpack的核心。

#### 三、基础配置
Webpack4以后的版本支持零配置启动打包，打包过程会按照'src/index.js' => 'dist/main.js'这种约定来打包。如果需要自定义打包路径，需要再webpack.config.js的配置文件中来自定义配置。

Webpack.config.js
```js
const path = require('path')

module.exports = {
  /**
   * 导入模块资源：入口文件路径
   * 1. 如果是相对路径不能省略./
   * 2. 打包入口也是运行入口，webpack建议入口文件时js文件，其它静态资源通过导入js的方式使用
   * 3. webpack打包出的静态资源是指在js中使用的部分
   *    js从宏观上讲驱动了整个前端应用，在实现业务过程中需要一些静态资源
   *    这样的做法一是逻辑合理，js需要这些资源文件，二是确保上线资源都是必要的
   * */
  entry: './src/main.js',
  /**
   * 输出文件配置
   * 接收一个object类型的数据
   * */
  output: {
    filename: 'bundle.js', // 文件名
    path: path.join(__dirname, 'output'), // 输出文件路径，必须是绝对路径
    publicPath: 'dist/' // 打包后的文件在网站中的位置，默认为空代表网站的根目录，其中dist后面的/不能省略
  },
  /**
   * 工作模式-针对于运行环境的几种配置
   * 默认-none，生产环境-development， 开发环境-production
   * */
  mode: 'development',
  /**
   * 资源模块
   * loader是webpack的核心特性，借助于Loader就可以加载任何类型的资源
   * */
  module: {
    rules: [
      /**
       * css加载器
       * webpack打包时，多个loader是从后往前执行的
       * css-loader：将css文件中的代码提取出来，转换为一个js模块放在一个数组中
       * style-loader：将css-loader转换后的结果，放到style标签中后添加到页面上
       * */
      {
        test: /.css$/,
        use: [
          'style-loader', 
          'css-loader'
        ]
      },
      /**
       * 文件资源加载器：将加载的资源模块拷贝到输出目录，并将文件访问路径导出
       * Data URLs：data:[<mediatype>][;base64],<data>
       * 1. 一种特殊的url协议，将文件进行base64编码，以代码的形式表述一个文件，不要发送http请求
       * 2. 使用方式：小文件使用Data URLs，减少请求次数；
       * 大文件单独提取存放(file-loader)，提高加载速度
       * 3. 注意url-loader不能处理的文件会交给file-loader处理，所以file-loader不能删除
       * */
      {
        test: /.png$/,
        use: {
          loader: 'url-loader',
          options: {
            // 超出10KB文件单独提取（file-loader）存放；小于10KB文件转换为Data URLs嵌入代码中
            limit: 10 * 1024 // 10 KB
          }
        }
      },
      /**
       * 代码检查类加载器 eslint-loader
       * */
      /**
       * js编译加载器：Webpack只是打包工具，加载器可以用来编译转换代码
       * */
      {
        test: /.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'] // babel只是一个平台，转换es2015是通过preset-env转换对应的版本的
          }
        }
      },
    ]
  }
}
```
命令
```shell
# 安装webpack
yarn add webpack webpack-cli --dev

# 打包
yarn webpack

# 指定工作模式
yarn webpack --mode development
```

#### 四、资源加载器（Loader）
##### 1. 常用loader使用方式

loader是webpack的核心特性，借助于Loader就可以加载任何类型的资源

```js
const path = require('path')

module.exports = {
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'output'),
    publicPath: 'dist/'
  },
  module: {
    rules: [
      /**
       * css加载器
       * webpack打包时，多个loader是从后往前执行的
       * css-loader：将css文件中的代码提取出来，转换为一个js模块放在一个数组中
       * style-loader：将css-loader转换后的结果，放到style标签中后添加到页面上
       * */
      {
        test: /.css$/,
        use: [
          'style-loader', 
          'css-loader'
        ]
      },
      /**
       * 文件资源加载器：将加载的资源模块拷贝到输出目录，并将文件访问路径导出
       * Data URLs：data:[<mediatype>][;base64],<data>
       * 1. 一种特殊的url协议，将文件进行base64编码，以代码的形式表述一个文件，不要发送http请求
       * 2. 使用方式：小文件使用Data URLs，减少请求次数；
       * 大文件单独提取存放(file-loader)，提高加载速度
       * 3. 注意url-loader不能处理的文件会交给file-loader处理，所以file-loader不能删除
       * */
      {
        test: /.png$/,
        use: {
          loader: 'url-loader',
          options: {
            // 超出10KB文件单独提取（file-loader）存放；小于10KB文件转换为Data URLs嵌入代码中
            limit: 10 * 1024 // 10 KB
          }
        }
      },
      /**
       * 代码检查类加载器 eslint-loader
       * */
      /**
       * js编译加载器：Webpack只是打包工具，加载器可以用来编译转换代码
       * */
      {
        test: /.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'] // babel只是一个平台，转换es2015是通过preset-env转换对应的版本的js
          }
        }
      },
      {
        test: /.html$/,
        use: {
          loader: 'html-loader',
          options: {
            attrs: ['img:src', 'a:href'] // 加载时对其它标签属性的支持，默认为['img:src']
          }
        }
      }
    ]
  }
}
```
安装命令
```shell
# 安装css资源模块
yarn add css-loader --dev

# 安装文件资源加载器
yarn add file-loader --dev

# 安装url加载器
yarn add url-loader --dev

# 安装js编译加载器
yarn add babel-loader @babel/core @babel/preset-env --dev

# 安装html加载器
yarn add html-loader --dev
```

##### 2. 自定义loader

- Loader加载资源的过程类似于一个工作管道，我们可以依次使用多个loader，但是管道输出的结果必须是一个js语法
- Loader负责资源文件从输入到输出的转换，对于同一个资源可以依次使用多个Loader，内部实现其实就是一个function

markdown-loader.js
```js
const marked = require('marked')

module.exports = source => {
  const html = marked(source)

  // 1. 返回一段js代码
  return `module.exports = "${html}"`
  return `export default ${JSON.stringify(html)}`

  // 2. 返回 html 字符串交给下一个 loader 处理
  return html
}
```
webpack.config.js
```js
const path = require('path')

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
    publicPath: 'dist/'
  },
  module: {
    rules: [
      {
        test: /.md$/,
        use: [
          'html-loader',
          './markdown-loader'
        ] 
      }
    ]
  }
}
```
#### 五、插件机制（Plugin）

- loader和plugin的区别：loader只是在加载模块的环节工作，plugin的工作范围触及到webpack工作的每一个环节

Plugin 增强了Webpack的自动化能力，比如清除dist目录，拷贝静态文件至输出目录，压缩输出代码等功能

##### 1. 常用插件使用方式

```shell
# 清除文件插件
yarn add clean-webpack-plugin --dev

# html插件
yarn add html-webpack-plugin --dev

# 拷贝插件
yarn add copy-webpack-plugin --dev
```

webpack.config.js

```js
const path = require('path')
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist')
  },
  module: {
    rules: [
      //...loaders
    ]
  },
  plugins: [
    new webpack.ProgressPlugin(), 
    new CleanWebpackPlugin(), // 自动清除输出目录
    // 用于生成index.html
    new HtmlWebpackPlugin({ // 自动生成使用bundle.js的HTML
        title: 'Html标题',
        meta: { // 源数据标签
            viewport: 'width=device-width'
        },
        template: './src/index.html'
    }),
    // 用于生成 about.html
    new HtmlWebpackPlugin({
      filename: 'about.html'
    }),
    // 将public下的所有文件拷贝到输出目录
    // 注意：开发阶段最好不要使用这个插件，因为在开发过程中会频繁执行打包任务，所以此插件一般用于上线前生产环境的插件
    new CopyWebpackPlugin([
      // 'public/**'
      'public'
    ])
  ]
}
```

html模板

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Webpack</title>
</head>
<body>
  <div class="container">
    <h1><%= htmlWebpackPlugin.options.title %></h1>
  </div>
</body>
</html>
```

##### 2. 自定义插件

plugin通过在生命周期的钩子中挂载函数实现扩展，钩子是一个函数或者是一个包含apply方法的对象

webpack.config.js

```js
const path = require('path')

// 自定义插件：将打包输出的js中的注释清除
class MyPlugin {
  apply (compiler) {
    console.log('MyPlugin 启动')

    compiler.hooks.emit.tap('MyPlugin', compilation => {
      // compilation => 可以理解为此次打包的上下文
      for (const name in compilation.assets) {
        if (name.endsWith('.js')) {
          const contents = compilation.assets[name].source()
          const withoutComments = contents.replace(/\/\*\*+\*\//g, '')
          compilation.assets[name] = {
            source: () => withoutComments,
            size: () => withoutComments.length
          }
        }
      }
    })
  }
}

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist')
  },
  module: {
    // ...loaders
  },
  plugins: [
    new MyPlugin()
  ]
}
```

#### 六、增强开发体验

##### 1. 自动编译

修改源代码后webpack自动编译，可以通过在打包命令后添加 --watch的方式实现

```shell
yarn webpack --watch
```

##### 2. 自动刷新浏览器

全局安装browser-sync，修改源代码后自动监听输出目录（dist）文件的变化，刷新浏览器

```shell
browser-sync dist --files "**/*"
```

##### 3. Dev Server 开发服务器

- 提供用于开发的HTTP Server，集成自动编译和自动刷新浏览器等功能，为了提高效率，webpack-dev-server将打包结果暂时写入了内存中，减少不必要的磁盘读写操作

```shell
# 安装
yarn add webpack-dev-server --dev

# 运行
yarn webpack-dev-server
```

webpack.config.js

```js
const path = require('path')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist')
  },
  devServer: {
    // Dev Server默认只会serve打包输出文件，其他不需要打包的文件需要 额外为开发服务器指定查找资源目录
    contentBase: './public',
    // 反向代理服务，将接口服务代理到本地开发服务器
    proxy: {
      '/api': {
        // http://localhost:8080/api/users -> https://api.github.com/api/users
        target: 'https://api.github.com',
        // http://localhost:8080/api/users -> https://api.github.com/users
        pathRewrite: {
          '^/api': ''
        },
        // 使用代理请求的地址作为主机名，不能使用 localhost:8080 作为请求 GitHub 的主机名，服务器不识别
        changeOrigin: true
      }
    }
  },
  module: {
    // ...loaders
  },
  plugins: [
    // ...plugins
  ]
}
```

##### 4. Source Map 源代码地图

###### 简介

生产环境中运行的代码与开发阶段的源代码之间完全不同，如果需要调试应用，或者运行中错误信息无法定位，因为调试和报错都是基于运行代码。所以Source Map 的作用就是**用来映射转换后的代码与源代码之间的关系**，转换后的代码可以通过Source Map转换后的文件逆向得到源代码。Source Map解决了源代码与运行代码不一致所产生的问题

###### 文件格式

map文件格式：jquery-3.4.1.min.map

```json
{
  "version": 3,  // 当前文件使用的source map标准的版本
  "sources": ["jquery-3.4.1"], // 转换之前源文件的名称
  "names": [], // 源代码中的有意义的变量名
  "mappings": "", // 转换之后代码中的字符与转换之前的字符对应的映射关系- base64编码
}
```

待转换的文件末尾需要添加map注释

```js
console.log('js语法')
//# sourceMappingURL=jquery-3.4.1.min.map
```

###### webpack中的配置

webpack.config.js

```js
const path = require('path')

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist')
  },
  // 12种不同的实现方式， 每种方式的效率和效果各不相同，效果最好的生成速度越慢
  devtool: 'source-map',
  module: {
    // ...loaders
  },
  plugins: [
    // ...plugins
  ]
}
```

- devtool属性值-12中sourcemap模式
  - build：初次构建速度
  - rebuild：监视模式重新打包速度
  - production: 是否适合在生产环境中使用
  - quality： 生成的source map 文件的代码质量

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf0af24602c041878d4df406c48f16c3~tplv-k3u1fbpfcp-watermark.image)

###### 不同的模式对比

- eval：是否使用eval执行模块代码

  ```js
  eval('console.log(123) //# sourceURL=webpack:///./src/main.js')
  ```

- cheap：是否包含行信息 

- module：是否能够得到Loader处理之前的源代码

- inline：将sourcemap以dataURL的方式嵌入到代码中

  webpack.config.js

  ```js
  const HtmlWebpackPlugin = require('html-webpack-plugin')
  
  const allModes = [
  	'eval', // 将打包后的代码放在eval函数中执行，通过sourceURL标记改变文件名称。缺点：只能定位源代码的文件名称，不能定位行列信息
    'eval-source-map', // 在eval基础上增加了定位行列信息功能
  	'cheap-eval-source-map', // 在eval-source-map基础上阉割了列信息，只能定位到行信息
  	'cheap-module-eval-source-map', // 在cheap-eval-source-map基础上，定位的源码是es6模块转换之前的代码
  	'cheap-source-map',
  	'cheap-module-source-map',
  	'inline-cheap-source-map',
  	'inline-cheap-module-source-map',
  	'source-map',
  	'inline-source-map', // 将sourcemap以dataURL的方式嵌入到代码中，缺点：导致代码体积变大
  	'hidden-source-map', // 将sourcemap引入源文件的注释隐藏掉，为了开发第三方库的时候使用
  	'nosources-source-map' // 能看到错误出现的位置，但是没有源代码，为了生产环境中保护源代码泄漏的情况
  ]
  
  module.exports = allModes.map(item => {
  	return {
  		devtool: item,
  		mode: 'none',
  		entry: './src/main.js',
  		output: {
  			filename: `js/${item}.js`
  		},
  		module: {
  			rules: [
  				{
  					test: /\.js$/,
  					use: {
  						loader: 'babel-loader',
  						options: {
  							presets: ['@babel/preset-env']
  						}
  					}
  				}
  			]
  		},
  		plugins: [
  			new HtmlWebpackPlugin({
  				filename: `${item}.html`
  			})
  		]
  	}
  })
  ```

###### 模式选择

选择没有绝对，理解不同模式的差异，适配不同的环境

开发模式：cheap-module-eval-source-map

- 代码每行不超过80个字符，所以只需要定位到行
- 第三方库多，代码警告loader转换后的差异较大
- 首次打包速度慢无所谓，重新打包相对较快

生产模式：none

- Source Map会暴露源代码，便利的同时会带来隐患
- 调试是开发阶段的事情

##### 5. HMR 模块热更新/替换

- Dev Server自动刷新依然存在问题，因为页面的实时刷新，页面中监测的状态不能保存，会导致没有存储的数据清空。为了保证页面不刷新的前提下，模块也可以及时更新，webpack提供了模块热更新的概念，简称HMR。
- 热替换类似于USB插口，在一个正在运行的机器上随时插拔设备，而机器的运行的状态不会收到影响，而且插上的设备可以立即工作。
- 模块热替换在**应用运行过程中只将修改的模块实时替换到应用中，应用运行状态不受影响**。HMR是Webpack中最强大的功能之一，极大程度的提高了开发者的工作效率

使用HMR

- 命令行模式：

```shell
$ webpack-dev-server --hot
```

- 配置文件：webpack.config.js

模块化热替换并不能开箱即用，样式文件可以通过loader热更新到style标签内，js模块没有规律，不可以直接热更新框架下的开发，每种文件都是有规律的，通过脚手架创建的项目内部都集成了HMR方案

```js
const webpack = require('webpack')

module.exports = {
  mode: 'development',
  entry: './src/main.js',
  output: {
    filename: 'js/bundle.js'
  },
  devtool: 'source-map',
  devServer: {
    hot: true 
    // 如果热替换失败，不使用自动刷新功能时，使用hotOnly
    // 只使用 HMR，不会 fallback 到 live reloading
    hotOnly: true
  },
  module: {
    // ...loaders
  },
  plugins: [
    // ...plugins
    new webpack.HotModuleReplacementPlugin() // webpack提供的HMR API
  ]
}
```

main.js入口文件

```js
// ...业务代码
import createEditor from './editor'
import background from './better.png'
import './global.css'

const editor = createEditor()
document.body.appendChild(editor)

const img = new Image()
img.src = background
document.body.appendChild(img)

// ============ HMR相关 ============

if (module.hot) { // 如果配置中没有启用模块热替换，不需要手动配置
  let lastEditor = editor
  // js热替换：以下代码只是针对于编辑器的业务场景实现的模块热替换，因为业务千变万化，webpack没有提供一整套的HMR解决方案
  module.hot.accept('./editor', () => {
    // console.log('editor 模块更新了，需要这里手动处理热替换逻辑')

    // 将内容存储  
    const value = lastEditor.innerHTML
    document.body.removeChild(lastEditor)
    const newEditor = createEditor()
    // 将存储的内容添加回来
    newEditor.innerHTML = value
    document.body.appendChild(newEditor)
    lastEditor = newEditor
  })
  
  // 图片热替换
  module.hot.accept('./better.png', () => {
    img.src = background
    console.log(background)
  })
 }
```

#### 七、环境分离

生产环境和开发环境有很大差异，生产环境注重运行效率，开发环境注重开发效率，webpack建议开发者为不同的工作环境创建不同的配置。

##### 1. 配置文件根据环境不同导出不同配置

```js
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const CopyWebpackPlugin = require('copy-webpack-plugin')

module.exports = (env, argv) => { // env 环境名参数 argv 所有参数
  const config = {
    mode: 'development',
    entry: './src/main.js',
    output: {
      filename: 'js/bundle.js'
    },
    devtool: 'cheap-eval-module-source-map',
    devServer: {
      hot: true,
      contentBase: 'public'
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ]
        },
        {
          test: /\.(png|jpe?g|gif)$/,
          use: {
            loader: 'file-loader',
            options: {
              outputPath: 'img',
              name: '[name].[ext]'
            }
          }
        }
      ]
    },
    plugins: [
      new HtmlWebpackPlugin({
        title: 'Webpack Tutorial',
        template: './src/index.html'
      }),
      new webpack.HotModuleReplacementPlugin()
    ]
  }

  if (env === 'production') {
    config.mode = 'production'
    config.devtool = false
    config.plugins = [
      ...config.plugins,
      new CleanWebpackPlugin(),
      new CopyWebpackPlugin(['public'])
    ]
  }

  return config
}
```

##### 2. 一个环境对应一个配置文件

webpack.common.js

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: './src/main.js',
  output: {
    filename: 'js/bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      },
      {
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: 'file-loader',
          options: {
            outputPath: 'img',
            name: '[name].[ext]'
          }
        }
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'Webpack Tutorial',
      template: './src/index.html'
    })
  ]
}
```

webpack.dev.js

```js
const webpack = require('webpack')
const merge = require('webpack-merge')
const common = require('./webpack.common')

module.exports = merge(common, {
  mode: 'development',
  devtool: 'cheap-eval-module-source-map',
  devServer: {
    hot: true,
    contentBase: 'public'
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
})
```

webpack.prod.js

```js
const merge = require('webpack-merge')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const CopyWebpackPlugin = require('copy-webpack-plugin')
const common = require('./webpack.common')

module.exports = merge(common, {
  mode: 'production',
  plugins: [
    new CleanWebpackPlugin(),
    new CopyWebpackPlugin(['public'])
  ]
})
```

运行打包命令

```shell
yarn webpack --config webpack.prod.js
```

#### 八、优化打包结果

##### 1. Defineplugin 

为代码注入全局成员，production模式默认启用，为代码中注入一个process.env.NODE_ENV的环境常量。可以用来为代码注入一些可能会变化的值。

```js
const webpack = require('webpack')

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js'
  },
  plugins: [
    new webpack.DefinePlugin({
      // 值要求的是一个代码片段，因为值会直接替换到打包代码中
      API_BASE_URL: JSON.stringify('https://api.example.com')
    })
  ]
}
```

##### 2. Tree-shaking

- "摇掉"代码中未引用部分（dead-code）,去除冗余代码，会在production模式下自动开启
- tree shaking 不是指某个配置选项，是一组功能搭配使用后的优化效果
- tree shaking的前提是ES Modules，由webpack 打包的代码必须使用ESM方式实现模块化

webpack.config.js

```js
module.exports = {
  mode: 'none',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              // 如果 Babel 加载模块时已经转换了 ESM，则会导致 Tree Shaking 失效
              // ['@babel/preset-env', { modules: 'commonjs' }]
              // ['@babel/preset-env', { modules: false }]
              // 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 ESM 转换
              ['@babel/preset-env', { modules: 'auto' }]
            ]
          }
        }
      }
    ]
  },
  optimization: {
    // 模块只导出被使用的成员,负责标记“枯树叶”
    usedExports: true,
    // 压缩输出结果，负责“摇掉枯树叶”
    minimize: true,
    // Scope Hoisting 作用域提升
    // 尽可能将所有模块合并，并输出到一个函数中
    concatenateModules: true
  }
}
```

##### 3. sideEffects 副作用

- 模块执行时除了导出成员之外所作的事情，一般用于npm包标记是否有副作用，会在production模式下自动开启
- 开启后，webpack在打包时会检查代码所属的package.json中是否有sideEffects 标识，检查是否副作用
- 使用sideEffects的前提是完全确保你的项目没有副作用，否则会误删有副作用的代码（比如基于原型的拓展方法）

webpack.config.js

```js
module.exports = {
  mode: 'none',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js'
  },
  module: {
   // ...loaders
  },
  optimization: {
    sideEffects: true // 开启副作用代码删除功能
  }
}
```

package.json

```json
{
  "name": "31-side-effects",
  "version": "0.1.0",
  "main": "index.js",
  "author": "zce <w@zce.me> (https://zce.me)",
  "license": "MIT",
  "scripts": {
    "build": "webpack"
  },
  "devDependencies": {
    "css-loader": "^3.2.0",
    "style-loader": "^1.0.0",
    "webpack": "^4.41.2",
    "webpack-cli": "^3.3.9"
  },
  "sideEffects": [ // 标识项目有副作用的代码
    "./src/extend.js",
    "*.css"
  ]
}
```

extend.js

```js
// 为 Number 的原型添加一个扩展方法
Number.prototype.pad = function (size) {
  // 将数字转为字符串 => '8'
  let result = this + ''
  // 在数字前补指定个数的 0 => '008'
  while (result.length < size) {
    result = '0' + result
  }
  return result
}
```

##### 4. code splitting 代码分包/分割

项目中所有的代码最终都会被打包到一起，如果应用非常负责，bundle体积会非常大，但是并不是没给模块在启动时都是必要的，所以分包、按需加载可以减轻浏览器端的流量和带宽（HTTP1.1版本存在同域并行请求限制，每次并行请求都有延迟的缺陷）

###### 多入口打包

webpack.config.js

```js
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'none',
  entry: { // 这里只有以对象的方式书写属性，才可以分多个入口打包，如果是数组会合并为一个入口
    index: './src/index.js',
    album: './src/album.js'
  },
  output: {
    filename: '[name].bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'Multi Entry',
      template: './src/index.html',
      filename: 'index.html',
      chunks: ['index'] // 指定页面对应的模块，只导入index.js作为入口
    }),
    new HtmlWebpackPlugin({
      title: 'Multi Entry',
      template: './src/album.html',
      filename: 'album.html',
      chunks: ['album']
    })
  ],
  optimization: {
    // 提取公共模块
    splitChunks: {
      // 自动提取所有公共模块到单独 bundle
      chunks: 'all'
    }
  }
}
```

###### 动态导入

实现模块的按需加载（Dynamic import），就是需要用到某个模块时，再加载这个模块，所有动态导入的模块会被自动分包

场景：点击哪个按钮导入哪个模块

入口文件index.js

```js
// import posts from './posts/posts'
// import album from './album/album'

const render = () => {
  const hash = window.location.hash || '#posts'

  const mainElement = document.querySelector('.main')

  mainElement.innerHTML = ''

  if (hash === '#posts') {
    // mainElement.appendChild(posts())
    // 魔法注释：给分包导出的bundle命名， 相同名字的包最后会打包到一起（components.bundle.js）
    import(/* webpackChunkName: 'components' */'./posts/posts').then(({ default: posts }) => {
      mainElement.appendChild(posts())
    })
  } else if (hash === '#album') {
    // mainElement.appendChild(album())
    import(/* webpackChunkName: 'components' */'./album/album').then(({ default: album }) => {
      mainElement.appendChild(album())
    })
  }
}

render()

window.addEventListener('hashchange', render)
```

###### 提取css优化

1. MiniCssExtractPlugin 提取css到单个文件
2. optimize-css-assets-webpack-plugin 压缩提取后的css为一行

```shell
# 安装提取css文件插件
$ yarn add mini-css-extract-plugin

# 安装压缩css插件
$ yarn add optimize-css-assets-webpack-plugin 
```

​	webpack.config.js

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const TerserWebpackPlugin = require('terser-webpack-plugin')

module.exports = {
  mode: 'none',
  entry: {
    main: './src/index.js'
  },
  output: {
    // 文件名增加hash值，一旦资源文件发生变化，文件名也会跟着变化，避免缓存更新问题
    // hash 任何改变全部都会变化
    // chunkhash 每一个模块的hash都是不一样的，只有修改具体的模块才会改变
    // contenthash 根据文件内容生成hash值，每个文件的hash都不一样
    // :8为hash值的长度
    filename: '[name]-[hash:8].bundle.js'
  },
  optimization: {
    minimizer: [ // 只有在minimize开启时才会工作，webpack推荐压缩类的插件配置在这里统一控制
      new TerserWebpackPlugin(), // js压缩器
      new OptimizeCssAssetsWebpackPlugin() // css压缩器
    ]
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // 'style-loader', // 将样式通过 style 标签注入
          MiniCssExtractPlugin.loader, // 将样式单独存放在文件中，通过link方式注入html
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    // ...plugins
    new MiniCssExtractPlugin()
  ]
}
```



### Rollup

Rollup仅仅是一个**ESM的打包器**，并不完全支持类似HMR这种高级特性，诞生的初衷是为了提供一个充分利用ESM各项特性的高效打包器，充分利用ESM特性构建出结构比较扁平，性能比较出众的类库。

特点：

- rollup输出的结果只会保留使用的部分，因为rollup会自动开启**tree shaking**
- 插件是Rollup唯一的扩展途径 
- rollup只能通过加载本地文件路径的方式加载模块，加载npm第三方库模块需要插件

缺点：

- 加载非ESM的第三方模块比较复杂
- 模块最终都被打包到一个函数中，无法实现HMR
- 浏览器环境中，代码拆分功能依赖AMD库
- 不适合开发应用程序（分包，加载ESM等），建议选择Webpack 

优点：

- 适合开发一个框架或者类库，大多数知名框架/库都在使用rollup
- 对于webpack，社区希望二者并存，**Webpack大而全，Rollup小而美**

#### 基本使用

```shell
# 安装
$ yarn add rollup --dev

# 运行 yarn rollup 入口文件路径 输出格式标准 输出文件路径
$ yarn rollup ./src/index.js --format iife --file dist.bundle.js

# 使用配置文件运行
$ yarn rollup --config

# 指定配置文件名称
$ yarn rollup --config rollup.config.js

# 安装导入json文件插件
$ yarn add rollup-plugin-json --dev

# 安装加载npm模块插件
$ yarn add lodash-es --save-dev
$ yarn add rollup-plugin-node-resolve --dev

# 安置加载commonJS模块插件
$ yarn add rollup-plugin-commonjs --dev
```

rollup.config.js

```js
// rollup支持import等ESM标准导入导出
import json from 'rollup-plugin-json'
import resolve from 'rollup-plugin-node-resolve'
import commonjs from 'rollup-plugin-commonjs'

export default {
  input: 'src/index.js', // 入口文件路径
  output: {
    file: 'dist/bundle.js',
    format: 'iife'
  },
  plugins: [ // 将调用结果放在这里
    json(),
    resolve(),
    commonjs()
  ]
}
```

src/index.js

```js
// 导入模块成员
import _ from 'lodash-es'
import { log } from './logger'
import messages from './messages'
import { name, version } from '../package.json'
import cjs from './cjs-module'

// 使用模块成员
const msg = messages.hi

log(msg)

log(name)
log(version)
log(_.camelCase('hello world'))
log(cjs)
```

src/cjs-module.js

```js
module.exports = {
  foo: 'bar'
}
```

#### code splitting 代码拆分

rollup.config.js

```js
export default {
  input: 'src/index.js',
  output: {
    // file: 'dist/bundle.js',
    // format: 'iife'
    dir: 'dist', // file只能输出一个文件，如果输出多个文件需要指定输出文件夹
    format: 'amd' // iife是自动执行函数形式，会把所有的模块都放在同一个文件中，没办法实现代码拆分
  }
}
```

src/index.js

```js
// 代码拆分需要异步导入
import('./logger').then(({ log }) => {
  log('code splitting~')
})
```

src/logger.js

```js
export const log = msg => {
  console.log('---------- INFO ----------')
  console.log(msg)
  console.log('--------------------------')
}

export const error = msg => {
  console.error('---------- ERROR ----------')
  console.error(msg)
  console.error('---------------------------')
}
```

####  多入口打包

rollup.config.js

```js
export default {
  // input: ['src/index.js', 'src/album.js'],
  input: {
    foo: 'src/index.js',
    bar: 'src/album.js'
  },
  output: {
    dir: 'dist',
    format: 'amd' // 多入口打包会自动提取公共模块
  }
}
```

dist/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <!-- AMD 标准格式的输出 bundle 不能直接引用 -->
  <!-- <script src="foo.js"></script> -->
  <!-- 需要 Require.js 这样的库 -->
  <script src="https://unpkg.com/requirejs@2.3.6/require.js" data-main="foo.js"></script>
</body>
</html>

```

#### 多入口多格式

rollup.config,js

```js
export default [
  {
    input: 'src/index.js',
    output: {
      file: 'dist/bundle.iife.js',
      format: 'iife'
    }
  },
  {
    input: 'src/index.js',
    output: {
      file: 'dist/bundle.cjs.js',
      format: 'cjs'
    }
  },
  {
    input: 'src/index.js',
    output: {
      file: 'dist/bundle.esm.js',
      format: 'esm'
    }
  },
  {
    input: 'src/index.js',
    output: {
      file: 'dist/bundle.amd.js',
      format: 'amd'
    }
  },
  {
    input: 'src/index.js',
    output: {
      file: 'dist/bundle.system.js',
      format: 'system'
    }
  },
  {
    input: 'src/index.js',
    output: {
      file: 'dist/bundle.umd.js',
      format: 'umd'
    }
  }
]
```

### Parcel

完全零配置的前端应用打包器，2017年首次发布版本，因为当时的Webpack使用上过于繁琐

- 支持多种格式入口文件，官方建议使用html文件作为打包入口，因为html是运行在浏览器端的入口
- 打包后默认启动开发服务器，端口号1234，文件改变会自动更新
- 默认支持模块热替换，接收一个回调函数
- 默认支持自动安装依赖功能，导入什么就会自动安装什么插件（npm install），样式和图片亦如此
- 默认支持动态导入
- 构建速度快，打包时内部采用的多进程同时工作的方式，充分发挥了多核cpu的性能（wepack中可以使用happy pack）

缺点：

- 相比webpack生态不够完善
- webpack越来越好用，所以使用parcel的人很少

```shell
# 安装npm模块
$ yarn add parcel-bundler --dev

# 开发模式将运行
$ yarn parcel src/index.html

# 生成模式打包
$ yarn parcel build src/index.html
```

src/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Parcel Tutorials</title>
</head>
<body>
  <script src="main.js"></script>
</body>
</html>
```

main.js

```js
// import $ from 'jquery'
import foo from './foo'
import './style.css'
import logo from './zce.png'

foo.bar()

// 支持动态导入
import('jquery').then($ => {
  $(document.body).append('<h1>Hello Parcel</h1>')

  $(document.body).append(`<img src="${logo}" />`)
})

// 默认支持模块热替换
if (module.hot) {
  module.hot.accept(() => { // 当前模块或当前模块依赖的模块更新后执行
    console.log('hmr')
  })
}
```

foo.js

```js
export default {
  bar: () => {
    console.log('hello parcel~')
  }
}
```

## 规范化标准

产生：因为软件开发需要多人协同，不同开发者有不同的编码习惯和喜好，这样增加项目维护成本，所以每个项目或者团队需要明确统一的标准 

使用场景：代码、文档、甚至是提交日志等，开发过程中人为编写的成果物，都需要标准化规范，其中代码标准化规范规范最重要。代码的格式化规范包括统一**关键词、操作符左右的空格、代码的缩进方式、是否使用分号结尾、变量函数命名规范**等。

实施方法：编码前人为的标准约定，在code review的时候检查约定的规范。为了减少人为的错误率，可以通过工具实现Lint等自动化检查工具。 

### ESlint

ESlint是最为主流的Javascript lint工具，负责监测JS代码质量，可以很容易统一开发者的编码规范，同时可以帮助开发者提升编码能力。所以 无论是从提升代码质量，还是提升自身编码水平，ESlint都有很大的作用。

#### 基本使用

```shell
# 安装
$ yarn add eslint --save-dev

# 运行
$ yarn eslint ./index.js | npx eslint

# 初始化配置文件
$ yarn eslint --init
? Check Syntax-检查语法: 未正确调用的函数等
? Find Problems-找出问题代码：未使用过的变量/函数等
? Enforce Code Style-代码风格校验：不统一的缩进，换行等
? type of modules-模块化类型：ESM/Commonjs/None
? frameWork-框架:React/Vue/None
? use Typescript-使用ts：No
? code run-代码运行环境：Browser浏览器环境/Node环境
? style for project-代码风格：主流风格/自定义/根据文件内容
? style guide-编码规范：airbnb/standard/google
? config format-配置文件格式：js/yaml/json

# 自动修复
$ yarn eslint .\index.js --fix
```

问题代码,index.js

```js
// 从未使用的变量
const foo = 123

// 从未声明的函数
fn()

function aa () {
  // 未正确换行，空格过多
  console.log("hello");  console.log("world");
}

// 未正确调用
aa(
```

.eslintrc.js： eslint配置文件

```js
module.exports = {
  // 标记当前代码最终的运行环境 
  env: {
    browser: true,
    es2020: true
  },
  // 继承共享配置
  extends: [
    "standard"
  ],
  // 设置语法解析器
  parserOptions: {
    ecmaVersion: 11 // es版本
  },
  // 配置校验规则
  rules: {
    "no-alert": "error" // error报错 warn警告 off关闭
  },
  // 额外声明代码中可以使用的全局成员
  globals: {
    "jQuery": "readonly"
  }
}
```

env环境配置参数

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fd133a8a56f4f25a5cefb02de9f4a79~tplv-k3u1fbpfcp-watermark.image)

#### 配置注释

http://eslint.cn/docs/user-guide/configuring#configuring-rules

```js
// 一行中全部忽略eslint检查
const str1 = `${name} is a coder` // eslint-disable-line

// 一行中的某个特性忽略eslint检查
const str1 = `${name} is a coder` // eslint-disable-line no-template-curly-in-string

console.log(str1)
```

#### 结合自动化工具

集成之后，ESlint一定会工作，优点是与项目统一，管理更加方便

1. gulp

   ```shell
   # 安装（安装gulp-load-plugin后 不需要手动加载gulp-eslint）
   $ yarn add gulp-eslint --save-dev
   
   # 初始化配置
   $ yarn eslint --init
   
   # 运行js脚本任务
   $ yarn gulp script
   ```

   gulpfile.js

   ```js
   const loadPlugins = require('gulp-load-plugins')
   const plugins = loadPlugins()
   
   // 编译js脚本
   const script = () => {
     return src('src/assets/scripts/*.js', { base: 'src' })
     	.pipe(plugins.eslint())
     	.pipe(plugins.eslint.format())
     	.pipe(plugins.eslint.failAfterError())
       .pipe(plugins.babel({ presets: ['@babel/preset-env'] }))
       .pipe(dest('temp'))
       .pipe(bs.reload({ stream: true }))
   }
   
   ```

2. Webpack

   ```shell
   # 安装
   $ yarn add eslint-loader --save-dev
   
   # 安装react相关插件
   $ yarn add eslint-plugin-react
   ```

   webpack.config.js

   ```js
   module.exports = {
     mode: 'production',
     entry: './src/main.js',
     module: {
       rules：[
       	{
       		test: /\.js$/,
       		exclude: /node_modules/,
       		use: 'eslint-loader',
       		enforce: 'pre'
     		}
     	]
     }
   }
   ```

   .eslintrc.js

   ```js
   module.exports = {
     env: {
       browser: true,
       es2020: true
     },
     extends: [
       "standard",
       "plugin:react/recommended"
     ],
     parserOptions: {
       ecmaVersion: 1
     },
     rules: {
       // 'react/jsx-uses-react': 2,
       // 'react/jsx-uses-vars': 2
     },
     plugins: [
       // 'react'
     ]
   }
   ```

#### 检查Typescript

```shell
$ yarn add typescript --dev
$ yarn add @typescript-eslint/eslint-plugin --save-dev
$ yarn add @typescript-eslint/parser --save-dev
$ yarn add eslint --save-dev
```

.eslintrc.js

```js
module.exports = {
  env: {
    browser: true,
    es2020: true
  },
  extends: [
    'standard'
  ],
  // 指定语法解析器
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 11
  },
  plugins: [
    '@typescript-eslint'
  ],
  rules: {
  }
}
```

### Stylelint

- 提供默认的css代码检查规则
- 提供cli工具，快速调用
- 通过插件支持Sass/Less/PostCSS
- 支持Gulp或Webpack集成

```shell
# 安装
$ yarn add stylelint --dev

# 运行
$ yarn stylelint ./index.css

# 安装共享配置模块
$ yarn add stylelint-config-standard --dev

# 安装sass检查依赖
$ yarn add stylelint-config-sass-guidelines --dev
```

.stylelintrc.js

```js
module.exports = {
	extends: [
    "stylelint-config-standard",
    "stylelint-config-sass-guidelines"
  ]
}
```

### Prettier

代码格式化工具，通过使用Prettier，可以很容易落实前端的规范化标准

```shell
# 安装
$ yarn add prettier --dev

# 执行
$ yarn prettier ./index.css

# 执行并覆盖源文件
$ yarn prettier ./index.css --write 

# 执行并覆盖全部源文件
$ yarn prettier . --write 
```

### GIt  Hooks

- 为了避免开发者代码提交仓库之前未执行lint工作，提交有问题的代码至远程仓库，出现了Git Hooks。
- Git Hooks也称之为git钩子，每个钩子都对应一个任务。
- 工作机制：可以通过shell脚本可以编写钩子任务触发时要具体执行的操作。

  .git/hooks/pre-commit

  ```shell
  #!/bin/sh
  echo "before commit"
  ```

#### 配合eslint使用

```shell
# 安装husky:由于前端开发者不熟悉shell脚本命令，所以可以使用npm模块—Husky，它可以实现Git Hooks的使用需求
$ yarn add husky --dev

# 安装lint钩子
$ yarn add lint-staged --dev
```

package.json

```json
// ...其它配置
"scripts": {
  "test": "eslint ./index.js",
  "precommit": "lint-staged"
},
"husky": {
  "hooks": {
    "pre-commit": "npm run precommit"
  }
},
// 代码提交前强制lint
"lint-staged": {
  "*.js": {
    "eslint",
    "git add"
  }
}
```

