## 数据结构

### 一维

线性表：通过索引去访问，例如js中的数组

#### 链表

链表是很多个数据，通过引用的方式访问

操作：

- 尾增数据
- 头删数据
- 中间增删数据

```ts
// 用js实现链表
class Node {
  private value: any
  private next: Node
  
  constructor (val) {
    this.value = val
	}
  
  setNext (nextVal) {
    if(this.next) {
      this.next.value = nextVal
    } else {
      this.next = new Node(nextVal)
    }
	}
}


class LinkList {
  private head
  
  constructor(value) {
    
  }
  
  add (value) {
    if(!this.head) {
      this.head = new Node(value)
    } else {
      var node = this.head
      while(!node.next) {
        
      }
    }
  }
}

new LinkList(1)

var obj1 = {next: null}
var obj2 = {next: obj1}
var obj3 = {head: obj2}
```

### 队列queue

一个管道，先进的先出。队列是有length，例如长度10，插入11数字个第1个就会出来。

与数组的区别：队列是一个受限制的数组，并且中间不能操作

### 栈stack

一个桶，先进后出，后进先出

### 多维

## 算法

1. 冒泡排序

   - 遍历数组，然后将最大数沉到最底部
   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)

   实现

   1. 两层for循环，第一层递减循环确定剩余比较个数
   2. 第二层递增循环负责比较，交换位置

2. 选择排序

   - 遍历数组，把最小数放在头部
   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)

   实现

   1. 两层递增循环，第二层负责将最小元素的索引找到
   2. 第一层用来比较当前索引的元素和最小元素的索引是否相同
   3. 如果不同，互换位置，将最小的元素放在数组头部
   4. 如果相同循环结束

3. 插入排序

   1. 将一个新的数，和前面的比较，只要当前数小于前一个则和前一个交换位置，否则终止
   2. 时间复杂度：O(N^2)
   3. 空间复杂度：O(1)

   实现

   1.  第一层递增循环，确定置换元素的开始位置
   2.  第二层递减循环，从最后一个位置逐次向前比较，如果后>前，置换位置

4. 归并排序

   1. 思路
      1. 先左侧部分排好序
      2. 再右侧部分排好序
      3. 再准备一个辅助数组，用外排的方式，小的开始填，直到有个动到末尾，将另一个数组剩余部分拷贝到末尾
      4. 再将辅助数组拷贝回原数组
   2. 时间复杂度:O(n*logN)
   3. 空间复杂度:O(n)

5. 快速排序

   1. 思路：随机取出一个值进行划分，大于该值放右边，小于该值放左边（该算法在经典快排的基础上经过荷兰国旗思想和随机思想进行了改造）
   2. 时间复杂度：O(n*logN)
   3. 空间复杂度：O(logN)

6. 堆排序

   1. 思路
      1. 让数组变成大根堆
      2. 把最后一个位置和堆顶做交换
      3. 则最大值在最后，则剩下部分做heapify，则重新调整为大根堆，则堆顶位置和该部分最后位置做交换
      4. 重复进行，直到减完，则这样最后就调整完毕，整个数组排完序（为一个升序）
   2. 时间复杂度:O(n*logN)
   3. 空间复杂度:O(1)

7. 桶排序

   1. 思路
      1. 准备桶：数组中有N个数就准备N+1个桶
      2. 遍历一遍数组，找到最大值max和最小值min 。若min = max，则差值=0；若min≠max，则最小值放在0号桶，最大值放在N号桶，剩下的数属于哪个范围就进哪个桶
      3. 根据鸽笼原理，则肯定有一个桶为空桶，设计该桶的目的是为了否定最大值在一个桶中，则最大差值的两个数一定来自于两个桶，但空桶两侧并不一定是最大值
      4. 所以只记录所有进入该桶的最小值min和最大值max和一个布尔值表示该桶有没有值
      5. 然后遍历这个数组，如果桶是空的，则跳到下一个数，如果桶非空，则找前一个非空桶，则最大差值=当前桶min - 上一个非空桶max，用全局变量更新最大值
   2. 时间复杂度：O(N)
   3. 空间复杂度：O(N)

8. 二分查找

9. 用两个栈实现一个队列

10. 以最快的方式取出数组中第二大的值

11. “abcabcdabcdeabcdefhijklmnkjhxlkdslkcjdslk”，查找字符串中最长的连续字母片段

12. js实现大数相加

## 设计模式