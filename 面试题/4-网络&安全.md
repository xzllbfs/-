## 浏览器

1. 异步加载JS脚本的方式有哪些？
   1. 动态创建 `script` 标签
   2. XHR 异步加载JS
2. `defer` 和 `async` 的区别
   - defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；
   - async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
   - 如果有多个 `defer` 脚本，会按照它们在页面出现的顺序加载
   - 多个 `async` 脚本不能保证加载顺序

## 基础

1. 浏览器有哪些进程？
   1. 主进程：负责浏览器界面显示；各个页面的管理，创建以及销毁；将渲染进程的结果绘制到用户界面上；网络资源管理
   2. GPU 进程：用于 3D 渲染绘制
   3. 网络进程：发起网络请求
   4. 插件进程：第三方插件处理，运行在沙箱中
   5. 渲染进程：页面渲染、脚本执行、事件处理
2. **一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？**
   1. 用户输入过程中，浏览器进行下拉联想，根据历史记录补全url，或者添加http协议头
   2. 判断强缓存：是否存在未过期的缓存，如果存在直接渲染页面，否则发起网络请求
   3. 网络请求阶段：
      1. DNS解析域名，读取缓存的ip地址，向服务端发起请求
      2. 建立TCP连接
      3. 浏览器发送get请求
      4. 服务端如果负载均衡的服务器，就会分发给具体的服务器
      5. 返回数据，浏览器根据状态码确认缓存方式(判断协商缓存)
         - 304-读取缓存文件
         - 200-覆盖or创建新的缓存文件
   4. 如果文件是html，开始渲染页面
   5. 页面渲染阶段：
      1. 处理HTML标记，通过HTML Parser+CSS Parser 构建 DOM Tree + CSSOM Tree
         - Doctype：浏览器通过判断文档类型来决定用什么模式来解析，以及切换浏览器模式
         - meta：用来定义的元信息：渲染模式，SEO相关信息
         - title：显示页面标题
         - link：通过href加载或解析外链资源，主要是css
         - style：正常情况下，css不会阻塞DOM树渲染，除非有通过@import动态导入的样式才会阻塞
         - script：正常情况下，js会阻塞页面渲染，除了外链的js添加defer属性
         - img：不会阻塞DOM渲染，但是如果没有设置宽高，加载完成后会触发DOM回流
      2. 整合渲染树：DOM Tree + CSSOM Tree = Render Tree
      3. 布局=>回流/重排：根据渲染树，计算它们在设备视口内的确切位置和大小，生成layout Tree
      4. Painting：根据渲染树和回流得到的几何信息和节点的绝对像素绘制GUI，将图层转换为位图
      5. display：将内容都呈现出来，展示给用户
   6. 静置一段时间后关闭TCP连接

## 缓存

1. 缓存的优点？

   1. 减少了不必要的数据传输，节省带宽；
   2. 减少服务器负担，提升网站性能；
   3. 加快客户端加载网页的速度；
   4. 用户体验优化

2. 浏览器是如何缓存文件的？强缓存和协商缓存的区别是什么？

   1. 浏览器第一次请求资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，缓存响应头信息。
      - cache-control：控制缓存过期时间
      - Expries：兼容IE，等价于cache-control
      - Etag：资源唯一标识
      - last-modified：最后修改时间
   2. 再次请求资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；
   3. 如果时间过期，则向服务器发送请求，携带信息
      - If-None-Match：资源唯一标识
      - If-Modified-Since：最后修改时间
   4. 服务器收到请求后，优先比对Etag，Etag值一致则没有修改，命中**协商缓存**，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；
   5. 如果服务器收到的Etag没有值，则比对最后修改时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

3. Cache-control属性的值有哪些？

   1. max-age：资源有效期
   2. max-age=xxxx，public：客户端和代理服务器都可以缓存该资源；客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求
   3. max-age=xxxx，private：只让客户端可以缓存该资源；代理服务器不缓存，客户端在xxx秒内直接读取缓存,statu code:200
   4.  max-age=xxxx，immutable：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,status code:200 ，即使用户做了刷新操作，也不向服务器发起http请求
   5. no-cache：跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
   6. no-store：不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。

4. 刷新浏览器对浏览器缓存有什么影响？

   1. 地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；
   2. F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；
   3. ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。

5. 描述 cookie localStorage sessionStorage的区别

   **cookie**

   1. cookie 最初是用来client和server通讯，同时兼顾本地存储，通过document.cookie设置值
   2. cookie 的缺点
      - 存储空间小，最大**4KB**。因为在网速不发达的时代，数据大小会影响传输速度
      - http请求的时候会发送给服务器，增加请求数据量
      - document.cookie的API易用性差

   **localStorage和sessionStorage**

   1. 两者都是h5时代专门为存储设计的，最大可存储**5M**。
   2. 两者API更加简易，通过getItem，set就可以存取，不会随着http请求发送出去
   3. localStorage 数据会永久存储，除非使用代码或手动删除，常用
   4. sessionStorage 数据只存在于当前会话，浏览器关闭则清空


## 请求

1. 如何解决跨域问题?

   同源策略：两个url的协议，域名，端口三者必须一致，不如不一致访问的数据需要进行跨域处理。

   跨域：所有的跨域都必须经过server端允许和配合，未经允许的跨域实现，说明浏览器有漏洞

   1. JSONP：由于`<script>`可以无视同源策略，并且浏览器可以任意动态拼接数据返回，所以可以`<script>`的异步加载可以获得跨域的数据。
   2. CORS 跨域资源共享：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源
   3. 本地服务代理：利用服务器访问服务器没有跨域问题的原理，先向代理(同源)服务器发起请求，再由代理(同源)服务器请求外部服务器
   4. Websoket：浏览器与服务器全双工通信，同时允许跨域通讯
   5. postMessage：A窗口通过postMessage发送数据，B窗口通过addEventListener('message')接收数据
   6. 两个iframe通信
      - document.domain：两个窗口可以共享同一个字段名
      - window.name：两个窗口可以共享同一个字段名
      - location.hash：利用window.onhashchange，监听两个iframe通信的数据

   **预检请求**: 需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响

2. 发起网络请求的过程？

   1. DNS解析域名对应的ip地址，向服务端发起请求
   2. 建立TCP连接，浏览器和服务器彼此确认是否具有传输数据的能力
   3. 浏览器开始请求，经过负载均衡的服务器分发给具体的服务器
   4. 服务端返回数据，浏览器根据状态码做下一步操作

3. 发起HTTP请求的方式有哪些？fetch 、XMLHttpRequest、$.ajax几种请求方式的区别

   1. fetch 是基于 XMLHttpRequest 基础上新增的API，写法更简洁，但是浏览器兼容性不太好
   2. fetch(url, params)返回一个promise对象
   3. fetch 仅当网络故障或请求被阻止时，才会标记为rejected状态，其它异常状态码都是在resolve的结果中将`ok`属性标记为 false
   4. 默认情况下，fetch不会从服务端发送或接收任何cookies

4. **XHR和fetch请求怎么取消？**

   取消fetch请求: new AbortController()、controller.signal传入fetch，controller.abort()取消

   ```js
   const controller = new AbortController()
   const { signal } = controller;
   
   fetch("http://localhost:8000", { signal }).then(response => {
       console.log(`Request 1 is complete!`);
   }).catch(e => {
       console.warn(`Fetch 1 error: ${e.message}`);
   });
   
   // Abort request
   controller.abort();
   ```

   取消xhr：xhr.abort()

   ```js
   let xhr = new XMLHttpRequest()
   xhr.method = 'GET'
   xhr.url = 'https://slowmo.glitch.me/5000'
   xhr.open(method, url, true)
   xhr.send();
   // 随后取消这个请求
   abortButton.addEventListener('click', function() {
   	xhr.abort()
   })
   ```

5. http常见的请求头和响应头字段有哪些？

   1. Accept：浏览器可接受的数据格式
   2. Accept-Encoding：浏览器可接收的压缩算法，如 gzip 使得资源变小，传输速度加快

   3. Accept-Language：浏览器可接收的语言，如 zh-CN
   4. Connection： keep-alive 一次tcp连接的重复使用
   5. cookie：同域请求浏览器携带的数据
   6. host 请求域名
   7. User-Agent（UA）浏览器信息，比如系统，移动端机型等
   8. Content-type：发送数据的格式，如 application/json，常用语post请求

6. http常见的响应头字段有哪些？

   1. Content-type 返回的数据格式，如 application/json
   2. Content-length 返回数据的大小， 多少字节
   3. Content-Encoding 返回数据的压缩算法，如 gzip
   4. Set-Cookie：服务端修改cookie

   缓存相关 headers

   1. Cache-control Expires
   2. Last-Modified If-Modified-Since
   3. Etag If-None-Match

7. http响应码有哪些？分别代表什么意思？

   1. 100：接受，服务器收到请求，没有返回

   2. 200：响应成功相关

      1. 201：Created 已创建，成功请求并创建了新的资源
      2. 204：No Content无内容，用于删除、更新成功等
      3. 206：收到部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码

   3. 300：资源发生变化，配合响应头location字段使用，浏览器自动处理

      1. 301：永久重定向
      2. 302：临时重定向
      3. 304 ：No Modified 命中协商缓存，资源未发生更改，告诉浏览器从缓存中读取文件

      重定向的作用：促进SEO优化，增加网页收集，有利于搜索引擎搜索

   4. 400：客户端错误，资源访问相关问题

      1. 401：要求身份认证
      2. 403：Forbidden 服务端理解但是拒绝请求，比如没有用户权限
      3. 404：服务器找不到资源
      4. 405：请求方式被禁止，除get和head之外的请求方式都可以被禁止
      5. 409：conflict 资源冲突，比如注册用户重名
      6. 422：请求参数错误

   5. 500：服务端错误

      1. 500：服务器错误
      2. 502：网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应
      3. 504：网关超时，服务器作为网关且不能从上游服务器及时的得到响应返回给客户端

8. CDN的原理，什么是cdn的回源？

   原理：解决服务器负载过大，静态资源请求延迟这两个问题

   1. 负载：将资源文件放在专门的cdn服务器上的，源服务器只用来处理数据的响应
   2. 延迟：DNS原理就是将就近服务器的ip地址返回，而不是去请求远程服务器，所以静态资源放在这个就近服务器，再去请求就会提升响应速度

   回源：cdn服务器上的资源是有失效时间的，资源失效之后, 去源头服务器上拉去最新的静态资源，这个过程叫做回源。但是如果所有cdn服务器都是定时去源服务器上拉取资源，就会对服务器造成负载，所以会在cdn服务器和源服务器中间加一层L2缓存服务器，只有L2缓存服务器才定期回源源服务器，然后其他cdn去L2缓存服务器上拉取，这样既可以达到效果，又可以减少对源服务器的压力

9. RestfulAPI是什么？http的请求方式有哪些？

   RestfulAPI是一种新的API设计理论，方便不同的前端设备与后端进行通信。传统API是把每个url当做一个功能，RestfulAPI是把每个url当做一个**资源**，前后端可以通过RestfulAPI定义的请求方式规范来传输数据。

   **请求方式**

   1. GET：获取资源
   2. POST：发送资源
   3. PUT：更新全部资源
   4. Patch：更新部分资源
   5. DELETE：删除资源
   6. HEAD：head方法用于获取报文首部，不返回报文主体
   7. OPTIONS：检查服务器的性能，获取服务器支持的http请求方式。是一种针对“跨域资源”的预检（Preflight）请求，用来判断实际发送的请求是否安全。

10. post和get的区别？

       1. Get 请求能缓存，Post 不能
       2. get用于请求资源，请求次数与资源无关，post用于提交资源
       3. GET 在浏览器回退时是无害的，而 POST 会再次提交
       4. Post 可以通过 request body 来传输比 Get 更多的数据，URL 有长度限制，会影响 Get 请求
       5. Post 支持**更多的编码类型**且不对数据类型限制
       6. Post 相对 Get 相对安全一些，因为 Get 请求都包含在 URL 中，而且会被浏览器保存记录，Post 不会。但是再抓包的情况下都是一样的。

11. URI和URL的区别？

    URI 是统一资源标识符，而 URL 是统一资源定位符。**每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。

12. 为什么说http协议是一个无状态的协议？

    HTTP协议不对**请求和响应之间的通信状态**进行保存，也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。但是可以用 Cookie 管理状态。

13. 应用层协议有哪些？

    应用层为应用程序提供服务并规定应用程序中通信相关的细节。其中包括：超文本传输协议HTTP，文件传送协议FTP，远程登录协议Telnet，简单邮件传送协议SMTP，DNS域名解析协议，简单文件传送协议TFTP，简单网络管理协议SNMP，动态主机配置协议DHCP。

14. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

    - 三次握手是为了证明浏览器和服务器彼此都有传送能力：第1,2次握手证明客户端的发送（SYN同步报文）和接收（ACK应答报文）能力，第3次握手证明服务端的发送和接收能力。
    - 四次挥手：因为关闭连接时，服务端B不能立刻关闭，如果突然关闭会导致进程崩掉，服务器异常。
      - 第1次挥手：浏览器A发送（FIN报文）关闭连接的请求
      - 第2次挥手：B回应确认收到（ACK报文）
      - 第3次挥手：B传送完毕发出传输释放的消息（FIN,ACK报文），等待A确认
      - 第4次挥手：A收到消息后，等待2MSL后，发送关闭消息

15. http协议各个版本之间的区别？

    1. HTTP/0.9：GET，无状态的特点形成

    2. HTTP/1.0：支持 POST，HEAD，添加了请求头和响应头，支持任何格式的文件发送，添加了状态码、多字符集支持、多部分发送、权限、缓存、内容编码等

    3. HTTP/1.1：默认长连接，同时 6 个 TCP 连接，CDN 域名分片

    4. HTTPS：HTTP + TLS（ **非对称加密** 与 **对称加密** ）

    5. 1. 客户端发出 https 请求，请求服务端建立 SSL 连接
       2. 服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端
       3. 户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥
       4. 客户端将公钥与客户端私钥进行对称加密后传给服务端
       5. 服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥
       6. 服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端
       7. 客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容

    6. HTTP/2.0：多路复用（一次 TCP 连接可以处理多个请求），服务器主动推送，stream 传输。

    7. HTTP/3：基于 UDP 实现了 QUIC 协议

    8. - 建立好 HTTP2 连接
       - 发送 HTTP2 扩展帧
       - 使用 QUIC 建立连接
       - 如果成功就断开 HTTP2 连接
       - 升级为 HTTP3 连接

16. TCP和UDP有什么区别？

    TCP协议连接是可靠的，因为服务端会有ACK响应。但UDP是不可靠的，没有服务端响应，比如QQ的早期版本用的就是UDP协议，因为网络不好，节省硬件消耗成本

## 安全

1. CSRF：确保请求是从某个具体的页面实时发出的，比如自动化脚本，页面保存到本地，劫持url跳转其它网站都能将请求从别的地方发出。

   防治手段

   - navigator.userAgent 读取浏览器请求头信息
   - 读取请求头里面的 referer 信息，即url地址、服务端发送csrf标识码（淘宝：csr_token）
   - 浏览器端携带标识码发请求，同时这个标识有过期时间
   - Cookie 的`SameSite`属性用来限制第三方 Cookie，从而减少安全风险     

2. XSS：确保输入类型的信息不会以源码的方式显示，包括用户输入的内容或服务端返回的内容。对标vue中的`v-html`输入的内容，一定要慎用，并且在显示之前做一个转换。

3. sql注入：将所有增删查改语句中加入了一些恒成立的语句，损坏数据库或泄露数据。防止手段：框架检测语句中的一些有风险的代码。

4. 反爬：防止别人获取你的数据

   防止手段：

    - 服务端限制请求次数，一个IP在一段时间内只能请求一次
    - 验证码：图形验证码防止机器学习
    - 串改html内容：将内容做成iconfont，设置`font-family`字体，设置背景图片`background-position`

6. 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？

   注入攻击中，攻击者给程序提供恶意的输入，解析引擎把恶意输入作为命令或者查询的一部分，顺带着改变了程序执行的流程。

   1. 存储性的和反弹性的XSS？
      - XSS攻击：跨站脚本攻击(Cross-Site Scripting)，攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。
      - 防御方法：过滤特殊字符，HttpOnly 浏览器禁止页面的JS访问带有HttpOnly属性的Cookie
   2. CSRF是为了解决什么问题？

7. 网页验证码是干嘛的，是为了解决什么安全问题。

8. 怎么实现反爬？

9. 安全相关 XSS的反射型是什么，怎么避免