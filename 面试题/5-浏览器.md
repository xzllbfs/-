**一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？**

1. 用户输入过程中，浏览器进行下拉联想，根据历史记录补全url，或者添加http协议头
2. 判断强缓存：是否存在未过期的缓存，如果存在直接渲染页面，否则进入网络请求阶段
   1. DNS解析域名对应的ip地址，向服务端发起请求
   2. 建立TCP连接
   3. 浏览器发送get请求
   4. 服务端如果负载均衡的服务器，就会分发给具体的服务器
   5. 返回数据，浏览器根据状态码确认缓存方式
      1. 304-读取缓存文件
      2. 200-覆盖or创建新的缓存文件
3. 得到html文件后进入页面渲染阶段
   1. 处理HTML标记，通过HTML Parser+CSS Parser 构建 DOM Tree + CSSOM Tree
      1. Doctype：浏览器通过判断文档类型来决定用什么模式来解析，以及切换浏览器模式
      2. Meta：用来定义的元信息：渲染模式，SEO相关信息
      3. title：显示页面标题
      4. Link：通过href加载或解析外链资源，主要是css
      5. CSS：正常情况下，css不会阻塞DOM树渲染，除非有通过@import动态导入的样式才会阻塞
      6. script：正常情况下，js会阻塞页面渲染，除了外链的js添加defer属性
      7. img：不会阻塞DOM渲染，但是如果没有设置宽高，加载完成后会触发DOM回流
   2. 整合渲染树：DOM Tree + CSSOM Tree = Render Tree
   3. 布局=>回流/重排：根据渲染树，计算它们在设备视口内的确切位置和大小
   4. Painting：根据渲染树和回流得到的几何信息和节点的绝对像素绘制GUI
   5. display：将内容都呈现出来，展示给用户
4. 静置一段时间后关闭TCP连接

## 网络请求

1. **如何解决跨域问题?**

   同源策略：发送请求时，浏览器要求网页与server必须同源，即协议，域名，端口三者必须一致，不如不一致访问的数据需要进行跨域处理。

   跨域：所有的跨域都必须经过server端允许和配合，未经允许的跨域实现，说明浏览器有漏洞

   1. CORS 跨域资源共享：生产环境，服务端设置
   2. 本地服务代理：开发环境
   3. JSONP：由于`<script>`可以无视同源策略，并且浏览器可以任意动态拼接数据返回，所以`<script>`可以获得跨域的数据。
   4. postMessage：
   5. 两个iframe通信
      - document.domain
      - window.name
      - location.hash
   6. flash URLLoader

   **服务端**

   - **使用 CORS 实现跨域调用**：CORS的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。

   - Access Control：请求的响应必须包含一个Access-Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。

   - **服务端代理**：通过server proxy的方式来抓取数据，在服务端配置代理，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略的限制），客户端并没有产生跨域的Ajax请求。

   **客户端**

   - 使用JSONP跨域：通过script标签引入的 js 不受同源策略的限制，而 XmlHttpRequest 对象受到同源策略的影响，可以加载跨域服务器上的脚本，用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。

     缺点：

     1）只能使用 GET 方法发起请求，不安全，这是由于 `script` 标签自身的限制决定的。
     2）不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。

   - window.name：当该window的location变化，然后重新加载，它的name属性可以依然保持不变。利用这一特性，可以将页面内嵌套一个iframe页面，将发送请求的数据赋值给window.name。这个方式非常适合**单向**的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。

   - **使用HTML5的postMessage方法**：这个功能主要包括接受信息的message事件和发送消息的postMessage方法。

   - document.domain：通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如baidu.com和 youxi.baidu.com是不同的域，这时，我们无法在baidu.com下的页面中调用youxi.baidu.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为baidu.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。

     缺点：

     1) 安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。
     2) 如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。

   - flash URLLoader：flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，我们可以借助flash来发送HTTP请求。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了。

   - location.hash：两个iframe之间，又称FIM，Fragment Identitier Messaging的简写。此方法的原理就是改变URL的hash部分来进行**双向通信**。
     缺点：
     1）通信造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变
     2）数据直接暴露在了url中，数据容量和类型都有限等。

2. 发起网络请求的过程？

   1. DNS解析域名对应的ip地址，向服务端发起请求
   2. 建立TCP连接，浏览器和服务器彼此确认是否具有传输数据的能力
   3. 浏览器开始请求，经过负载均衡的服务器分发给具体的服务器
   4. 服务端返回数据，浏览器根据状态码做下一步操作

3. http常见的请求头和响应头字段有哪些？

   **请求头**

   1. 接收内容：Accept，Accept-Charset，Accept-Encoding，Accept-Language，Accept-Ranges
   2. 请求内容：User-Agent，Content-Type（MIME信息），Content-Length，Referer，Host，If-Range，Range
   3. 连接：Connection，Authorization
   4. 缓存：Cookie，Cache-Control，If-Modified-Since，If-Match，If-None-Match，If-Unmodified-Since

   **响应头**

   1. 接收内容：Accept-Ranges，Allow
   2. 发送内容：Content-Encoding，Content-Language，Content-Length，Content-Location，Content-Range，Content-Type
   3. 定向：Location，refresh
   4. 缓存：Cache-Control，Expires，ETag，Last-Modified，Set-Cookie

4. http响应码有哪些？分别代表什么意思？

   1. 100：接受，服务器收到请求，没有返回
   2. 200：响应成功相关
      
      1. 201：Created 已创建，成功请求并创建了新的资源
      2. 204：No Content无内容，用于删除、更新成功等
      3. 206：收到部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码
   3. 300：资源发生变化，配合响应头location字段使用，浏览器自动处理
      
      1. 301：永久重定向
      2. 302：临时重定向
      3. 304 ：No Modified 命中协商缓存，资源未发生更改，告诉浏览器从缓存中读取文件
      
      重定向的作用：促进SEO优化，增加网页收集，有利于搜索引擎搜索
      
   4. 400：客户端错误，资源访问相关问题
      1. 401：要求身份认证
      2. 403：Forbidden 服务端理解但是拒绝请求，比如没有用户权限
      3. 404：服务器找不到资源
      4. 405：请求方式被禁止，除get和head之外的请求方式都可以被禁止
      5. 409：conflict 资源冲突，比如注册用户重名
      6. 422：请求参数错误
   5. 500：服务端错误
      1. 500：服务器错误
      2. 502：网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应
      3. 504：网关超时，服务器作为网关且不能从上游服务器及时的得到响应返回给客户端

5. CDN的原理，什么是cdn的回源？

   原理：解决服务器负载过大，静态资源请求延迟这两个问题

   1. 负载：将资源文件放在专门的cdn服务器上的，源服务器只用来处理数据的响应
   2. 延迟：DNS原理就是将就近服务器的ip地址返回，而不是去请求远程服务器，所以静态资源放在这个就近服务器，再去请求就会提升响应速度

   回源：cdn服务器上的资源是有失效时间的，资源失效之后, 去源头服务器上拉去最新的静态资源，这个过程叫做回源。但是如果所有cdn服务器都是定时去源服务器上拉取资源，就会对服务器造成负载，所以会在cdn服务器和源服务器中间加一层L2缓存服务器，只有L2缓存服务器才定期回源源服务器，然后其他cdn去L2缓存服务器上拉取，这样既可以达到效果，又可以减少对源服务器的压力

6. RestfulAPI是什么？http的请求方式有哪些？

   RestfulAPI是一种新的API设计理论，方便不同的前端设备与后端进行通信。传统API是把每个url当做一个功能，RestfulAPI是把每个url当做一个资源，前后端可以通过RestfulAPI定义的请求方式规范来传输数据。

   **请求方式**

   1. GET：获取资源
   2. POST：发送资源
   3. PUT：更新全部资源
   4. Patch：更新部分资源
   5. DELETE：删除资源
   6. HEAD：head方法用于获取报文首部，不返回报文主体
   7. OPTIONS：检查服务器的性能，获取服务器支持的http请求方式。是一种针对“跨域资源”的预检（Preflight）请求，用来判断实际发送的请求是否安全。

7. 发起HTTP请求的方式有哪些？

8. URI和URL的区别？

   **URI 是统一资源标识符，而 URL 是统一资源定位符。**每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。

9. 为什么说http协议是一个无状态的协议？

   HTTP协议**不**对请求和响应之间的通信状态进行保存，也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。

10. 应用层协议有哪些？

   应用层为应用程序提供服务并规定应用程序中通信相关的细节。其中包括：超文本传输协议HTTP，文件传送协议FTP，远程登录协议Telnet，简单邮件传送协议SMTP，DNS域名解析协议，简单文件传送协议TFTP，简单网络管理协议SNMP，动态主机配置协议DHCP。

11. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

    三次握手是为了证明浏览器和服务器彼此都有传送能力：第1,2次握手证明客户端的发送（SYN同步报文）和接收（ACK应答报文）能力，第3次握手证明服务端的发送和接收能力。

    四次挥手：因为关闭连接时，服务端B不能立刻关闭，如果突然关闭会导致进程崩掉，服务器异常。

    - 第1次挥手：浏览器A发送（FIN报文）关闭连接的请求
    - 第2次挥手：B回应确认收到（ACK报文）
    - 第3次挥手：B传送完毕发出传输释放的消息（FIN,ACK报文），等待A确认
    - 第4次挥手：A收到消息后，等待2MSL后，发送关闭消息

    https://www.jianshu.com/p/6b2e35fdaf2c

12. http协议各个版本之间的区别？

13. **XHR和fetch请求怎么取消？**

14. TCP和UDP有什么区别？

    TCP协议连接是可靠的，因为服务端会有ACK响应。但UDP是不可靠的，没有服务端响应，比如QQ的早期版本用的就是UDP协议，因为网络不好，节省硬件消耗成本

## 网络安全

1. CSRF：确保请求是从某个具体的页面实时发出的，比如自动化脚本，页面保存到本地，劫持url跳转其它网站都能将请求从别的地方发出。

   防治手段

   - `navigator.userAgent`读取浏览器请求头信息
   - 读取请求头里面的referer信息，即url地址、服务端发送csrf标识码（淘宝：csr_token）
   - 浏览器端携带标识码发请求，同时这个标识有过期时间
   - Cookie 的`SameSite`属性用来限制第三方 Cookie，从而减少安全风险     

2. XSS：确保输入类型的信息不会以源码的方式显示，包括用户输入的内容或服务端返回的内容。对标vue中的`v-html`输入的内容，一定要慎用，并且在显示之前做一个转换。

3. sql注入：将所有增删查改语句中加入了一些恒成立的语句，损坏数据库或泄露数据。防止手段：框架检测语句中的一些有风险的代码。

4. 反爬：防止别人获取你的数据

   防止手段：

    - 服务端限制请求次数，一个IP在一段时间内只能请求一次
    - 验证码：图形验证码防止机器学习
    - 串改html内容：将内容做成iconfont，设置`font-family`字体，设置背景图片`background-position`

5. 对前端安全有什么看法？

6. 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？

   注入攻击中，攻击者给程序提供恶意的输入，解析引擎把恶意输入作为命令或者查询的一部分，顺带着改变了程序执行的流程。

   1. 存储性的和反弹性的XSS？
      - XSS攻击：跨站脚本攻击(Cross-Site Scripting)，攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。
      - 防御方法：过滤特殊字符，HttpOnly 浏览器禁止页面的JS访问带有HttpOnly属性的Cookie
   2. CSRF是为了解决什么问题？

7. 网页验证码是干嘛的，是为了解决什么安全问题。

8. 怎么实现反爬？

9. 安全相关 XSS的反射型是什么，怎么避免


## HTML

1. 浏览器的渲染过程？

   1. 处理HTML标记，通过HTML Parser 构建DOM Tree
   2. 处理CSS标记，通过 CSS Parser 构建 CSSOM Tree
   3. 整合渲染树：DOM Tree + CSSOM Tree = Render Tree
   4. 回流=>布局/重排：根据渲染树，计算它们在设备视口内的确切位置和大小
   5. Painting：根据渲染树和回流得到的几何信息和节点的绝对像素进行绘制
   6. display：将内容都呈现出来，展示给用户

2. 浏览器解析html标签的具体过程？

   html标签的解析过程是在GUI渲染线程中进行的。

   1. Doctype：浏览器通过判断文档类型来决定用什么模式来解析，以及切换浏览器模式
   2. Meta：用来定义的元信息：渲染模式，SEO相关信息
   3. title：显示页面标题
   4. Link：通过href加载或解析外链资源，主要是样式
   5. CSS
      - link外链式 ：不阻塞DOM 树渲染，开辟HTTP线程加载资源
      - style内嵌式：不阻塞DOM树渲染，先记录下来，等所有css资源加载成功后，按照顺序依次渲染生成CSSOM树
      - @import导入式：阻塞DOM树渲染，开辟HTTP线程加载资源，资源加载回来，才会继续渲染
   6. script
      - 内嵌式：阻塞DOM树渲染，立即执行js
      - 普通外链式：阻塞DOM树渲染，同时开辟HTTP线程加载资源，加载回来后立即执行js
      - async外链式：开辟HTTP线程加载资源，继续渲染Dom树，加载完成停止DOM渲染，先执行js（不考虑导入顺序，按照加载回来的先后顺序执行）
      - defer外链式：开辟HTTP线程加载资源，等待DOM树渲染完，按照js导入顺序依次执行js
   7. img：不会阻塞DOM渲染，开辟HTTP线程加载src，加载回来后如果没有设置宽高会触发回流

4. 什么回流Reflow？触发机制有哪些？

   DOM结构中各个元素都有自己的盒模型，需要浏览器根据样式计算结果将元素放置在它该出现的位置上，这个过程称之为回流。

   **触发机制**

   - 增删改元素时，导致重绘和回流
   - 移动DOM位置或添加动画时
   - 修改css样式时
   - 浏览器窗口缩放Resize时，滚动页面时
   - 修改网页的默认字体时

5. 什么重绘Repaint？触发机制有哪些？

   当各种盒子的位置、大小、颜色、字体等确定之后，浏览器按照各自的特性绘制后呈现在在页面上，这个过程叫重绘。

   **触发机制**

   - Dom改动
   - Css改动

   **回流必将引起重绘，而重绘不一定会引起回流**

6. 什么是Doctype，它的作用是什么？传统模式和严格模式的区别？

      DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义XML或XHTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种模式来解析，以及切换浏览器模式。

      DOCTYPE是用来声明文档类型定义规范的，一个主要的用途就是验证文件的合法性。如果不合法，浏览器解析会出错。

      **DTD（文档类型定义）定义了一些文档类型，DOCTYPE将类型告诉浏览器，浏览器根据它来决定用什么模式来解析，以及切换浏览器模式。**

      传统模式：包含所有HTML元素和属性，**不包括**展示性和弃用的元素

      严格模式：包含所有HTML元素和属性，**包括**展示性和弃用的元素（浏览器能正常解析）

7. meta标签的viewport对应的content有哪些属性？

      1.  width：设置 viewport 的宽度，正整数/字符串 device-width
      2.  height：设置 viewport 的高度，正整数/字符串 device-height
      3.  initial-scale：设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数
      4.  maximum-scale：设置最大缩放系数，0.0-10.0之间的正数
      5.  minimum-scale：设置最小缩放系数，0.0-10.0之间的正数
      6.  user-scalable：如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no

8. 如何理解HTML语义化？

   HTML语义化可以增加代码可读性，有利于搜索引擎优化（SEO）

9. 哪些Html标签是块级元素，哪些是内联元素？

   - 块状元素指的是display:block/table 的元素，特点内容是可以**独占一行**。其中包括：div h1-h6 table ul ol p，pre
   - 内联元素指的是display:inline/inline-block的元素，特点是内容**依次连接直至浏览器的边缘换行**为止。其中包括：span img input button i figure

## 性能优化

1. 性能优化有哪些方面？

   1. 页面加载速度
   2. 请求响应速度
   
   3. 内存占用
   4. 动画流畅度
   5. 能耗：复杂canvas动画
2. 性能优化的手段有哪些？

     1. 关键渲染路径节点优化
     2. 减少http请求次数
     3. 设置各种缓存、预处理、长连接机制
     4. 防抖节流机制
     5. 长列表渲染优化
     6. 图片懒加载

3. 页面渲染时js阻塞的解决方法？

   阻塞的原理：浏览器在解析HTML页面是从上到下依次解析、渲染，如果`<head>`中引用了一个a.js文件，浏览器不知道a.js中执行了哪些脚本，会对页面造成什么影响，所以浏览器会等js文件下载并执行完成后才继续渲染，如果这个时间过长，会白屏。

   - 将script标签放在body底部
   - 动态加载script文件
   - script

4. 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？

5. 如何编写高性能的Javascript？

6. 那些操作会造成内存泄漏？

7. 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?

8. **图片懒加载的实现原理？**

   当打开一个有很多图片的页面时，先只加载页面上看到的图片，等滚动到页面下面时，再加载所需的图片。这就是图片懒加载。它的作用是减少或延迟请求数，缓解浏览器的压力，增强用户体验。

   - 设置图片src属性为同一张图片，同时自定义一个data-src属性来存储图片的真实地址
   - 页面初始化显示的时候或者浏览器发生滚动的时候判断图片是否在视野中
   - 当图片在视野中时，通过js自动改变该区域的图片的src属性为真实地址

9. 说一下V8的垃圾回收机制 （小米）

   主要思路：

   1. 新生代内存区分为两个等大小空间，使用空间为From，空闲空间为To
   2. 将所有对象存储于From空间（包括活动对象和非活动对象）
   3. 当From空间应用到一定程度后会触发GC机制，标记整理后将活动对象拷贝至To
   4. From完成释放（From和To交换空间）

   采用分代回收思想，v8内存空间一分为二

   小空间用于存储新生代对象，回收新生代采用**复制算法+标记整理**，新生代内存区分为两个大小相等的空间：使用空间为Form,存储活动对象。空闲空间为To,标记整理后将活动对象拷贝至To空间,最后From和To交换空间完成释放。

   大空间用于存储老生代对象,回收老生代采用 **标记清除+标记整理+增量标记算法：首先使用标记清除算法完成垃圾空间的回收,相对空间碎片问题,速度提升比较明显。标记整理针对的是新生代晋升老生代时,老生代内存空间不足的对象，最后会采用增量标记算法进行效率优化。

10. performance API 中什么指标可以衡量首屏时间？

   1）performance.timing

   - performance.timing.loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳,如果该事件还没有发生,返回 0。
   - performance.timing.navigationStart:当前浏览器窗口的前一个网页关闭,发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页,则等于 fetchStart 属性。

   ```js
     var t = performance.timing;
     // 首屏渲染时间
     var pageLoadTime = t.loadEventEnd - t.navigationStart;
   ```

   2）在vue的mounted生命周期中调用`performance.now()`得到当前网页 从`performance.timing.navigationStart` 到 当前时间的的 微秒数。

11. 性能优化
    https://www.cnblogs.com/wang-z-z/p/9485887.html

    1. 技术点
           1) PWA: Progressive Web Apps, 渐进式Web应用开发
           2) Lighthouse: 自动化测试工具
           3) SSR: Server Side Rendering, 服务端渲染
           4) NSR: Native Side Rendering, 客户端提前渲染
           5) Rehydration: 注水
       
    2. 优化技术的发展
           1) 2007年 - 雅虎军规、YSlow
           2) 2008年 - WebPageTest开源
           3) 2009年 - SPDY开始实验
           4) 2010年 - Facebook提出BigPipe
           5) 2012年 - HTTP/2提案、gQUIC初版规范提出
           6) 2015年 - 发布HTTP/2标准、RAIL性能模型、PageSpeed Insights
              (1) RAIL模型
                 Response - 100ms相应用户输入后
                 Animation - 每帧动画在16ms内完成
                 Idle - 最大化空闲时间
                 Load - 3G中等设备5s内可交互
                 为什么是50ms?
                   100ms = 50ms + 50ms
                   超过50ms被定义为long task
           7) 2016年 - PWA概念提出、Lighthouse开源
           8) 2017年 - PWA被迅速采用、AMP推出
           9)  2018年 - HTTP/3正式启用
           10) 2020年 - Web Vitals开始推广
       
    3. 性能优化的指标
           1) FP - 首次绘制(First Paint)
           1) FCP - 初次内容绘制时间(First Contentful paint)
           2) LCP - 最大内容绘制时间(Largest Contentful paint)
           3) FID - 首次输入后延迟(First Input delay)
           4) TTI - 页面可交互时间(Time To Interactive)
           5) TBT - 主线程累计阻塞时间(Total Blocking time)
           6) CLS - 累计布局偏移(Cumulative layout shift)
       
    4. 性能指什么?
           1) 加载速度
           2) 响应速度
           3) 动画流畅度
           4) 能耗
           5) 内存占用
       
    5. 常见的优化手段
           1) 缓存技术
              (1) 通用优化
                 * 使用CDN加速静态资源
                           * 合理设置缓存时间 Cache-Control
                 * 避免注册unload以影响前进后退缓存
                     (2) 前端最佳实践
          * 使用异步的Cache API/IndexDB
               e API主要存储HTTP请求,其他存储IndexDB
          * 尽量避免同步的LocalStorage, ~5M
               端的优化
          * 提供离线包,提前下发资源
               虑将离线包的资源预置进HTTP Cache

    9. 进一步考虑主文档、关键路径资源预置到Memory Cache
          技术
          
          ```html
          <link rel="dns-prefetch" href="//example.com">
          <link rel="preconnect" href="//example.com">
          <link rel="preconnect" href="//cdn.example.com" crossorigin>
          <link rel="prefetch" href="//example.com/next.html" as="document"
                crossorigin="use-credentials">
          <link rel="prefetch" href="/library.js" as="script">
          <link rel="prerender" href="//example.com/next-page.html">
          <link rel="preload" href="/styles/other.css" as="style">
          ```
          
          ​    3) 渲染方案
          ​       (1) 静态渲染 Static Rendering (SR)
          ​       (2) 前端渲染 Client Side Rendering (CSR)
          ​       (3) 服务端渲染 Server Side Rendering (SSR)
          ​       (4) 客户端渲染 Native Side Rendering (NSR)
          浏览器API
          ​    1) API类别
          ​      (1) Navigation Timing - ⻚⾯导航性能
          ​      (2) Resource Timing - ⼦资源加载性能
          ​      (3) Paint Timing - FP/FCP
          ​      (4) Element Timing - ⾃定义 LCP
          ​      (5) Event Timing - FID
          ​      (6) Layout Instability API - CLS
    ​      (7) Long Tasks API - ⻓任务优化
          ​      (8) Frame Timing - 慢帧优化
          ​    2) Performance Timeline
          ​      (1) Hight Resolution Time
          
             * performance.now()
                  formance.timeOrigin
                   * performance.toJSON()
                      (2) 三个接口
             * getEntries()
                  EntriesByType()
             * getEntriesByName()
                  个对象
             * PerformanceEntry
                  rformanceObserver
                        new PerformanceObserver((entryList) => {
                          for (const entry of entryList.getEntries()) {
                  console.log('LCP candidate', entry.startTime, entry)
                          }
                        }).observe({
                          type: 'largest-contentful-paint',
                          buffered: true
                        })
                      3) Navigation Timing
                         (1) performance.timing
                  startTime
                  unloadEventStart
                  unloadEventEnd
                  redirectStart
                  redirectEnd
                  fetchStart
                  domainLookupStart
                  domainLookupEnd
                  connectStart
                  secureConnectionStart
                  connectEnd
                  requestStart
                  responseStart
                  responseEnd
                  domInteractive
                  domContentLoadedEventStart
                  domContentLoadedEventEnd
                  domLoading
                  domComplete
                  loadEventStart
                  loadEventEnd
                         (2) performance.navigation.type
                         (3) performance.navigation.redirectCount
                         enum NavigationType {
                           "navigate",
                           "reload",
                           "back_forward",
                           "prerender"
                         }
                      4) Resource Timing
                          (1) performance.getEntriesByType('resource')
                  Timing-Allow-Origin
                      5) Paint Timing
                          (1) 收集FP, FCP两个指标
                  name: first-paint
                  name: first-contentful-paint
                          new PerformanceObserver((entries) => {
                  const prefEntries = entries.getEntries()
                  for (let i = 0; i < prefEntries.length; i++) {
                  console.log(prefEntries[i])
                  }
                          }).observe({
                  type: 'paint',
                          })
                      6) Event Timing
                         new PerformanceObserver((entries, observer) => {
                          const firstInput = entries.getEntries()[0]
                          const inputDelay = firstInput.processingStart - firstInput.startTime
                          // Report inputDelay to analytics
                          observer.disconnect()
                        }).observe({
                          type: 'first-input',
                          buffered: true
                        })
                      7) Frame Timing
                        { entryTypes: ['frame'] }
                      8) Long Tasks API
                         1) Long Task > 50ms
                        { entryTypes: ['longtask'] }

## 体验优化

1. 单页面程序如何做SEO？
2. 写代码的时候应该注意哪些SEO问题？

## 前端监控

1. 前端监控解决了什么问题？

   1）运营行为监控：帮助运营和公司做出战略或战术上的决策

   2）错误监控：帮助开发人员做异常监控（window.onerror监听，uncaught事件）

   3）性能监控：帮助开发人员发现前端性能问题，比如首屏加载时间，第一个元素的出现速度，页面加载完成时间等

2. 前端监控的常见指标有哪些？

   - pv页面访问量：页面被访问多少次
     - 位置：被访问的地域（ip地址）
     - 用户信息：脱敏信息，通过登录账户来确定
     - 加载时间：监听页面开始加载到离开的时间，来决定页面优化（unload和beforeunload）
   - uv用户访问量：被多少个用户访问，比如新老用户访问，可以设计招新或留存的营销策略
   - 曝光量：区块出现在可见范围内的次数
     - 首屏曝光：对比pv是否相同，用户是否真的访问这个区块
     - 非首屏曝光
   - 点击量：按钮、链接、区块被点击的次数

   有了这些指标可以评估页面的价值以及未来的优化策略，ABtest：对于两个方案所有指标测试的评估结果

## 题海

1. 页面编码和被请求的资源编码如果不一致如何处理？

2. 服务器代理转发时，该如何处理cookie?

3. 什么是RPC？

4. webSocket如何兼容低浏览器？

5. 怎么用get实现post，就是使用get方法但是参数放到request body中

6. WebSocket 是什么原理？为什么可以实现持久连接？

7. xhr.readyState请求状态码有哪些？分别代表什么意思？

   - 0-未初始化：还没有调用send()方法
   - 1-载入：已调用send()方法，正在发送请求
   - 2-载入完成：send方法执行完成，已经接收到全部响应内容
   - 3-交互：正在解析响应内容
   - 4-完成：响应内容解析完成，可以在客户端调用

8. 介绍一下你对浏览器内核的理解？常见的浏览器内核有哪些？

9. 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?

   渲染引擎Webkit

   执行引擎V8

10. 浏览器是怎样解析CSS选择器的？

11. performance API 中什么指标可以衡量首屏时间

12. 检测浏览器版本有哪些方式？

13. 什么是浏览器的同源策略？

14. title与h1的区别、b与strong的区别、i与em的区别？

    title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；

    `<strong><em>`标于相比与 `<b><i>` 标签更加侧重标签语义化，容易被搜索引擎抓取。应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。

    - 自然样式标签（Physical Style Elements）： b, i, u, s, pre
    - 语义样式标签（Semantic Style Elements）：strong, em, ins, del, code

15. meta标签有哪些常见属性？

    **charset**属性：定义网页文档的字符集

    ```html
    <meta charset="utf-8" />
    ```

    **name+content**属性：

    | 名称        | 描述                                                         |
    | ----------- | ------------------------------------------------------------ |
    | viewport    | 用户网页的可视区域，即“视区”，优化移动浏览器的显示。         |
    | keywords    | 网页关键词，描述该网页内容的一组唯一的关键字，内容不应超过 874 个字符 |
    | robots      | 搜索引擎索引方式，`robotterms`是一组使用逗号(,)分割的值，通常有如下几种取值：`none`，`noindex`，`nofollow`，`all`，`index`和`follow`。确保正确使用`nofollow`和`noindex`属性值。 |
    | author      | 网页作者                                                     |
    | website     | 网页地址                                                     |
    | copyright   | 网页版权信息                                                 |
    | description | 网页描述，准确反映网页内容的描述标签，内容不能超过 150 个字符 |
    | renderer    | 指定双核浏览器默认以何种方式渲染页面                         |
    | minimal-ui  | iOS 7.1Safari新增，在网页载入时默认隐藏地址栏与导航栏。      |

    ```html
    <!-- 网页作者 -->
    <meta name="author" content="开源技术团队"/>
    <!-- 网页地址 -->
    <meta name="website" content="https://sanyuan0704.github.io/frontend_daily_question/"/>
    <!-- 网页版权信息 -->
     <meta name="copyright" content="2018-2019 demo.com"/>
    <!-- 网页关键字, 用于SEO -->
    <meta name="keywords" content="meta,html"/>
    <!-- 网页描述 -->
    <meta name="description" content="网页描述"/>
    <!--浏览器渲染内核-->
    <meta name="renderer" content="webkit">
    <!--
    	webkit:页面用极速内核
      ie-comp：ie兼容内核
      ie-stand：ie标准内核
    -->
    <!-- 移动端常用视口设置 -->
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <!-- 
      viewport参数详解：
      width：设置 viewport 的宽度，正整数/字符串 device-width
      height：设置 viewport 的高度，正整数/字符串 device-height
      initial-scale：设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数
      maximum-scale：设置最大缩放系数，0.0-10.0之间的正数
      minimum-scale：设置最小缩放系数，0.0-10.0之间的正数
      user-scalable：如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no
     -->
    <meta name="robots" content="index,follow" />
    <!--
        all：文件将被检索，且页面上的链接可以被查询；
        none：文件将不被检索，且页面上的链接不可以被查询；
        index：文件将被检索；
        follow：页面上的链接可以被查询；
        noindex：文件将不被检索；
        nofollow：页面上的链接不可以被查询。
     -->
    ```

    **http-equiv+content属性**：

    ```html
    <!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 -->
    <meta http-equiv="expires" content="Fri, 12 Jan 2020 18:18:18 GMT"/>
    <!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 -->
    <meta http-equiv="refresh" content="1; url=https://www.baidu.com"/>
    <!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 -->
    <meta http-equiv="pragma" content="no-cache"/>
    <!-- 也是设置cookie的一种方式，并且可以指定过期时间 -->
    <meta http-equiv="set-cookie" content="name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/"/>
    <!-- 使用浏览器版本 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    ```

16. 怎么防止移动端页面缩放？

    1）meta标签

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    ```

    2）iOS 10之后不接受meta标签，可通过js监听手势控制：

    ```js
    document.addEventListener('gesturestart', function (event) {
        event.preventDefault()
    })
    ```

17. 页面导入样式时，使用link和@import有什么区别？

    - 形式上的区别：`link`属于XHTML标签，`@import`完全是CSS提供的一种方式。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，`@import`就只能加载CSS了。
    - 兼容性区别：由于`@import`是CSS2.1提出的，所以老的浏览器不支持，`@import`只有在IE5以上的才能识别，而link标签无此问题。
    - 加载顺序区别：当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而`@import`引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览`@import`加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。在使用webpack预编译的时候，extract-text-webpack-plugin会生成新的CSS文件。
    - dom控制样式时的区别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为`@import`不是dom可以控制的。

18. 什么是FOUC？你如何来避免FOUC？

    FOUC：文档样式短暂失效(Flash of Unstyled Content)的简称，浏览器以无样式显示页面内容的瞬间闪烁现象。

    场景：

    - 使用import方法导入样式表
    - 将样式表放在页面底部
    - 多个样式表放在HTML的不同位置

    原因：当样式表晚于结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。

    解决方案：使用link标签将样式表放在文档head中

19. 把`<script>`标签放在`</body>`之前和之后有什么区别？浏览器会如何解析它们？

    按照HTML5标准中的HTML语法规则，如果在`</body>`后再出现`<script>`或任何元素的开始标签，都是parse error，浏览器会忽略之前的`</body>`，即视作仍旧在body内。所以实际效果和写在`</body>`之前是没有区别的。

    浏览器解析时，所有标签都会解析进这 head 和body两个标签里边。body之前的任何位置都会解析进head里边，之后的都会解析进body里边。

20. 怎么实现script的异步加载？

    - 标签加上defer或async：两者的区别在于脚本加载完成之后何时执行，如果存在多个有defer属性的脚本，那么它们是按照加载顺序执行脚本的；而对于async，它的加载和执行是紧紧挨着的，无论声明顺序如何，只要加载完成就立刻执行，它对于应用脚本用处不大，因为它完全不考虑依赖。

    - 异步加载JS

      ```js
      getMap.onclick = function(){
         //获得需要插入的位置
         var oDiv = document.getElementById('div');
         //异步创建script
         var script = document.createElement('script');
      
         script.src = 'https://map.baidu.com/...'
      
         oDiv.appendChild(script)
       }
      ```

    - 通过 ajax 去获取 js 代码，然后通过 eval 执行

      ```js
      window.onload = function(){
          //1.创建XMLHttpRequest对象并考虑兼容性
          var xhr;
          if(window.XMLHttpRequest){
              //通用浏览器
              xhr = new XMLHttpRequest()
          }
          else{
              //IE5/6
              xhr = new ActiveXObject('Miscrosoft.XMLHttp')
          }
          
          //2.设置请求方式
          let url = ''
          xhr.open('get', url, true);//异步请求
          
          //3.发送请求
          xhr.send()
          
          //4.回调函数
          xhr.onreadyStateChange = function(){
              if(xhr.readyState == 4 && xhr.status == 200){
                  let script = xhr.responseText;
                  eval(script)   //异步加载script
              }
          }
      }
      ```

    - 创建并插入 iframe，让它异步执行 js

      ```js
      var iframe = document.createElement('iframe')
       document.body.appendChild(iframe)
       var doc = iframe.contentWindow.document
       doc.open().write('<body onload="insertJS()">')
       doc.close()
      ```

21. preload和prefetch的区别？

    浏览器资源加载优先级总共分为五级：very-high、high、medium、low、very-low，其中MainRescource页面、CSS、字体这三个的优先级是最高的，然后就是Script、Ajax这种，而图片、音视频的默认优先级是比较低的，最低的是prefetch预加载的资源。

    prefetch：有时候你可能需要让一些资源先加载好等着用，例如用户输入出错的时候在输入框右边显示一个X的图片，如果等要显示的时候再去加载就会有延时，这个时候可以用一个link标签：

    ```html
    <link rel="prefetch" href="image.png">
    ```

    preload：在早期浏览器，script资源是阻塞加载的，当页面遇到一个script，那么要等这个script下载和执行完了，才会继续解析剩下的DOM结构，也就是说script是串行加载的，并且会堵塞页面其它资源的加载，这样会导致页面整体的加载速度很慢，所以早在2008年的时候浏览器出了一个**推测加载策略**，即遇到script的时候，DOM会停止构建，但是会继续去搜索页面需要加载的资源，如看下后续的html有没有img/script标签，先进行预加载，而不用等到构建DOM的时候才去加载。这样大大提高了页面整体的加载速度。

22. iframe有哪些优缺点？

    iframe的优点：

    - 方便快捷，可以做多个页面的统一风格的头尾
    - 如果遇到加载缓慢的第三方内容（如图标和广告），这些问题可以由iframe来解决。

    iframe的缺点：

    - 会产生很多页面，不容易管理。
    - 用户体验差：框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力。
    - 不利于SEO：搜索引擎爬虫还不能很好的处理iframe中的内容
    - 兼容性差：很多的移动设备（PDA 手机）无法完全显示框架
    - iframe框架页面会增加服务器的http请求，对于大型网站是不可取的

23. HTML5与之前版本区别？

  - **文档类型声明方式**

  ```html
  <!DOCTYPE html>
  <mete charset="UTF-8">
  ```

  - **新增元素和属性**：布局、表单、音频视频

  - **更加适应时代要求**：移动互联网时代相比pc时代更加迫切希望有一个统一的标准。之前由于各个浏览器不统一，因为修改浏览器兼容引起的bug浪费了大量的时间。在HTML5中视频、音频、图像、动画都会标准化，会解决浏览器兼容这个令人头疼的问题。

2. 如何处理HTML5新标签的浏览器兼容问题？

   - 使用静态资源的html5shiv，在`<head>`中调用以下代码：

     ```html
     <!--[if lt IE9]>
     <script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
     <![endif]-->
     ```

   - 使用skill IE6:， 在`</body>`之前调用以下代码

     ```html
     <!--[if lte IE 6]>
       <script src="http://letskillie6.googlecode.com/svn/trunk/letskillie6.zh_CN.pack.js"></script>
     <![endif]-->
     ```

   - 载入后，初始化新标签的css

     ```css
     header, section, footer, aside, nav, main, article, figure { display: block; }
     ```

   - IE6/IE7/IE8支持通过 `document` 创建标签，利用这一特性让这些浏览器支持HTML5新标签

3. html5有哪些新特性、移除了那些元素？

   **新特性**

   **布局语义化标签**

   - **section**：表示页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分。它可以与h1、h2、h3、h4、h5、h6等元素结合起来使用标记文档结构。

   - **article**：表示页面中的一块与上下文不相关的独立内容，例如博客中的一篇文章。

   - **aside**：表示article元素内容之外的，与article元素相关的辅助信息。

   - **header**：表示页面中一个内容区块或整个页面的标题。

   - **hgroup**：用于整个页面或页面中一个内容区块的标题进行组合。

   - **footer**：用于整个页面或页面中一个内容区块的脚注。一般来说，它会包含创作者的姓名，创建日         期及创作者联系信息。

   - **nav**：表示页面中导航链接的部分。

   - **figure**：表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元，使用figcaption元素        为figure元素组添加标题。

     ![](https://upload-images.jianshu.io/upload_images/2355059-ff64e4b088393e84.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

   **form表单属性**

   - **form**：在html4中，表单内的从属元素必须书写在表单内部，但在html5中，可以书写在表单上任何位置，只需要给该元素制定一个form属性，属性值为表单的id就可以了，这样做的好处是给页面中的元素添加样式时更方便。
   - **formaction**：在html4中，表单内的所有元素都只能通过表单的action属性统一提交到另一个页面，但在html5中可以给所有的提交按钮都增加不同的formaction属性，使得点击不同的按钮，将表单提交到不同的页面。
   - **formmethod**：可以使用formmethod属性来对每个表单元素分别指定不同的提交方法。
   - **placeholder**：当文本框“text”或“textarea”处于未输入状态时文本框中显示的输入提示。
   - **autofocus**：当页面刚打开，文本框、选择框或按钮可以自动获得焦点。不过一个页面只能有一个控件使用该属性。
   - **list**：该属性需要和datalist元素（html5新增）一起使用，list属性的值就是datalist的id，使用datalist元素设置一个选择列表，当用户输入的值在列表中就出现选择提示，当用户想要设定的值不在选择列表之内时，允许其自行输入
   - **autocomplete**：可以指定“on”、“off”和“”三种值，不指定时，使用浏览器默认值。

   **视频和音频**：video、audio 

   **canvas画布**：图形容器、必须使用js脚本来绘制图形

   **移除的元素**：默认字体`<basefont>`、字体标签`<font>`、水平居中`<center>` 、下划线 `<u>`

4. HTML5的form如何关闭自动完成功能？

   - 在IE的Internet选项菜单里的内容--自动完成里面设置
   - 设置form的autocomplete为"off"来关闭form中所有输入框的自动完成功能
   - 设置input的autocomplete为"off"来关闭该输入框的自动完成功能

5. 页面可见性（Page Visibility API） 可以有哪些用途？

   Page Visibility API由以下三部分组成：

   - document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）

   - document.visibilityState：表示下面 4 个可能状态的值

     - hidden：页面在后台标签页中或者浏览器最小化，当浏览器最小化、切换tab、电脑锁屏时发生
     - visible：页面在前台标签页中，用户正在查看当前页面时发生
     - prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true，文档加载离屏或者不可见发生
     - unloaded：页面正在从内存中卸载，当文档将要被unload时发生

   - Visibilitychange事件：当文档从可见变为不可见或者从不可见变为可见时，会触发该事件

     ```js
     document.addEventListener('visibilitychange', function() {
     	console.log(document.visibilityState)
     }
     ```

   用途：当浏览器切换标签页的时候动画或者视频暂停播放，切换回来又继续播放动画或视频，可以使用Visibilitychange监测变化

6. 怎么实现图片压缩上传？fileReader API

   参考链接：

   1. https://www.imooc.com/article/72053
   2. https://www.cnblogs.com/hutuzhu/p/5265023.html

   

7. 什么是PWA？怎么实现PWA

   原文地址：https://segmentfault.com/a/1190000012353473

   PWA全称Progressive Web App，**即渐进式web应用**。一个PWA应用首先是一个网页，可以通过Web技术编写出一个网页应用。随后添加上App Manifest和Service Worker来实现PWA的安装和离线等功能，使得Web应用渐进式接近原生APP

   App Manifest：**Web应用程序清单**在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是**将Web应用程序安装到设备的主屏幕**，不需要用户通过应用商店，伴随着其他功能, 比如离线可用和接收推送通知，为用户提供更快的访问和更丰富的体验。

   Service Worker：Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。

   解决了哪些问题？

   - 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏
   - 实现离线缓存功能，即时用户手机没有网络，依然可以使用一些离线功能
   - 实现了消息推送