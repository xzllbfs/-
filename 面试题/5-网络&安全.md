**一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？**

1. 用户输入过程中，浏览器进行下拉联想，根据历史记录补全url，或者添加http协议头
2. 判断强缓存：是否存在未过期的缓存，如果存在直接渲染页面，否则进入网络请求阶段
   1. DNS解析域名对应的ip地址，向服务端发起请求
   2. 建立TCP连接
   3. 浏览器发送get请求
   4. 服务端如果负载均衡的服务器，就会分发给具体的服务器
   5. 返回数据，浏览器根据状态码确认缓存方式
      1. 304-读取缓存文件
      2. 200-覆盖or创建新的缓存文件
3. 得到html文件后进入页面渲染阶段
   1. 处理HTML标记，通过HTML Parser+CSS Parser 构建 DOM Tree + CSSOM Tree
      1. Doctype：浏览器通过判断文档类型来决定用什么模式来解析，以及切换浏览器模式
      2. Meta：用来定义的元信息：渲染模式，SEO相关信息
      3. title：显示页面标题
      4. Link：通过href加载或解析外链资源，主要是css
      5. CSS：正常情况下，css不会阻塞DOM树渲染，除非有通过@import动态导入的样式才会阻塞
      6. script：正常情况下，js会阻塞页面渲染，除了外链的js添加defer属性
      7. img：不会阻塞DOM渲染，但是如果没有设置宽高，加载完成后会触发DOM回流
   2. 整合渲染树：DOM Tree + CSSOM Tree = Render Tree
   3. 布局=>回流/重排：根据渲染树，计算它们在设备视口内的确切位置和大小
   4. Painting：根据渲染树和回流得到的几何信息和节点的绝对像素绘制GUI
   5. display：将内容都呈现出来，展示给用户
4. 静置一段时间后关闭TCP连接

## 浏览器缓存



## 网络请求

1. **如何解决跨域问题?**

   同源策略：发送请求时，浏览器要求网页与server必须同源，即协议，域名，端口三者必须一致，不如不一致访问的数据需要进行跨域处理。

   跨域：所有的跨域都必须经过server端允许和配合，未经允许的跨域实现，说明浏览器有漏洞

   1. CORS 跨域资源共享：生产环境，服务端设置
   2. 本地服务代理：开发环境
   3. JSONP：由于`<script>`可以无视同源策略，并且浏览器可以任意动态拼接数据返回，所以`<script>`可以获得跨域的数据。
   4. postMessage：
   5. 两个iframe通信
      - document.domain
      - window.name
      - location.hash
   6. flash URLLoader

   **服务端**

   - **使用 CORS 实现跨域调用**：CORS的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。

   - Access Control：请求的响应必须包含一个Access-Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。

   - **服务端代理**：通过server proxy的方式来抓取数据，在服务端配置代理，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略的限制），客户端并没有产生跨域的Ajax请求。

   **客户端**

   - 使用JSONP跨域：通过script标签引入的 js 不受同源策略的限制，而 XmlHttpRequest 对象受到同源策略的影响，可以加载跨域服务器上的脚本，用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。

     缺点：

     1）只能使用 GET 方法发起请求，不安全，这是由于 `script` 标签自身的限制决定的。
     2）不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。

   - window.name：当该window的location变化，然后重新加载，它的name属性可以依然保持不变。利用这一特性，可以将页面内嵌套一个iframe页面，将发送请求的数据赋值给window.name。这个方式非常适合**单向**的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。

   - **使用HTML5的postMessage方法**：这个功能主要包括接受信息的message事件和发送消息的postMessage方法。

   - document.domain：通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如baidu.com和 youxi.baidu.com是不同的域，这时，我们无法在baidu.com下的页面中调用youxi.baidu.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为baidu.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。

     缺点：

     1) 安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。
     2) 如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。

   - flash URLLoader：flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，我们可以借助flash来发送HTTP请求。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了。

   - location.hash：两个iframe之间，又称FIM，Fragment Identitier Messaging的简写。此方法的原理就是改变URL的hash部分来进行**双向通信**。
     缺点：
     1）通信造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变
     2）数据直接暴露在了url中，数据容量和类型都有限等。

2. 发起网络请求的过程？

   1. DNS解析域名对应的ip地址，向服务端发起请求
   2. 建立TCP连接，浏览器和服务器彼此确认是否具有传输数据的能力
   3. 浏览器开始请求，经过负载均衡的服务器分发给具体的服务器
   4. 服务端返回数据，浏览器根据状态码做下一步操作

3. http常见的请求头和响应头字段有哪些？

   **请求头**

   1. 接收内容：Accept，Accept-Charset，Accept-Encoding，Accept-Language，Accept-Ranges
   2. 请求内容：User-Agent，Content-Type（MIME信息），Content-Length，Referer，Host，If-Range，Range
   3. 连接：Connection，Authorization
   4. 缓存：Cookie，Cache-Control，If-Modified-Since，If-Match，If-None-Match，If-Unmodified-Since

   **响应头**

   1. 接收内容：Accept-Ranges，Allow
   2. 发送内容：Content-Encoding，Content-Language，Content-Length，Content-Location，Content-Range，Content-Type
   3. 定向：Location，refresh
   4. 缓存：Cache-Control，Expires，ETag，Last-Modified，Set-Cookie

4. http响应码有哪些？分别代表什么意思？

   1. 100：接受，服务器收到请求，没有返回

   2. 200：响应成功相关

      1. 201：Created 已创建，成功请求并创建了新的资源
      2. 204：No Content无内容，用于删除、更新成功等
      3. 206：收到部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码

   3. 300：资源发生变化，配合响应头location字段使用，浏览器自动处理

      1. 301：永久重定向
      2. 302：临时重定向
      3. 304 ：No Modified 命中协商缓存，资源未发生更改，告诉浏览器从缓存中读取文件

      重定向的作用：促进SEO优化，增加网页收集，有利于搜索引擎搜索

   4. 400：客户端错误，资源访问相关问题

      1. 401：要求身份认证
      2. 403：Forbidden 服务端理解但是拒绝请求，比如没有用户权限
      3. 404：服务器找不到资源
      4. 405：请求方式被禁止，除get和head之外的请求方式都可以被禁止
      5. 409：conflict 资源冲突，比如注册用户重名
      6. 422：请求参数错误

   5. 500：服务端错误

      1. 500：服务器错误
      2. 502：网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应
      3. 504：网关超时，服务器作为网关且不能从上游服务器及时的得到响应返回给客户端

5. CDN的原理，什么是cdn的回源？

   原理：解决服务器负载过大，静态资源请求延迟这两个问题

   1. 负载：将资源文件放在专门的cdn服务器上的，源服务器只用来处理数据的响应
   2. 延迟：DNS原理就是将就近服务器的ip地址返回，而不是去请求远程服务器，所以静态资源放在这个就近服务器，再去请求就会提升响应速度

   回源：cdn服务器上的资源是有失效时间的，资源失效之后, 去源头服务器上拉去最新的静态资源，这个过程叫做回源。但是如果所有cdn服务器都是定时去源服务器上拉取资源，就会对服务器造成负载，所以会在cdn服务器和源服务器中间加一层L2缓存服务器，只有L2缓存服务器才定期回源源服务器，然后其他cdn去L2缓存服务器上拉取，这样既可以达到效果，又可以减少对源服务器的压力

6. RestfulAPI是什么？http的请求方式有哪些？

   RestfulAPI是一种新的API设计理论，方便不同的前端设备与后端进行通信。传统API是把每个url当做一个功能，RestfulAPI是把每个url当做一个资源，前后端可以通过RestfulAPI定义的请求方式规范来传输数据。

   **请求方式**

   1. GET：获取资源
   2. POST：发送资源
   3. PUT：更新全部资源
   4. Patch：更新部分资源
   5. DELETE：删除资源
   6. HEAD：head方法用于获取报文首部，不返回报文主体
   7. OPTIONS：检查服务器的性能，获取服务器支持的http请求方式。是一种针对“跨域资源”的预检（Preflight）请求，用来判断实际发送的请求是否安全。

7. 发起HTTP请求的方式有哪些？

8. URI和URL的区别？

   **URI 是统一资源标识符，而 URL 是统一资源定位符。**每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。

9. 为什么说http协议是一个无状态的协议？

   HTTP协议**不**对请求和响应之间的通信状态进行保存，也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。

10. 应用层协议有哪些？

   应用层为应用程序提供服务并规定应用程序中通信相关的细节。其中包括：超文本传输协议HTTP，文件传送协议FTP，远程登录协议Telnet，简单邮件传送协议SMTP，DNS域名解析协议，简单文件传送协议TFTP，简单网络管理协议SNMP，动态主机配置协议DHCP。

11. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

    三次握手是为了证明浏览器和服务器彼此都有传送能力：第1,2次握手证明客户端的发送（SYN同步报文）和接收（ACK应答报文）能力，第3次握手证明服务端的发送和接收能力。

    四次挥手：因为关闭连接时，服务端B不能立刻关闭，如果突然关闭会导致进程崩掉，服务器异常。

    - 第1次挥手：浏览器A发送（FIN报文）关闭连接的请求
    - 第2次挥手：B回应确认收到（ACK报文）
    - 第3次挥手：B传送完毕发出传输释放的消息（FIN,ACK报文），等待A确认
    - 第4次挥手：A收到消息后，等待2MSL后，发送关闭消息

    https://www.jianshu.com/p/6b2e35fdaf2c

12. http协议各个版本之间的区别？

13. **XHR和fetch请求怎么取消？**

14. TCP和UDP有什么区别？

    TCP协议连接是可靠的，因为服务端会有ACK响应。但UDP是不可靠的，没有服务端响应，比如QQ的早期版本用的就是UDP协议，因为网络不好，节省硬件消耗成本

## 网络安全

1. CSRF：确保请求是从某个具体的页面实时发出的，比如自动化脚本，页面保存到本地，劫持url跳转其它网站都能将请求从别的地方发出。

   防治手段

   - `navigator.userAgent`读取浏览器请求头信息
   - 读取请求头里面的referer信息，即url地址、服务端发送csrf标识码（淘宝：csr_token）
   - 浏览器端携带标识码发请求，同时这个标识有过期时间
   - Cookie 的`SameSite`属性用来限制第三方 Cookie，从而减少安全风险     

2. XSS：确保输入类型的信息不会以源码的方式显示，包括用户输入的内容或服务端返回的内容。对标vue中的`v-html`输入的内容，一定要慎用，并且在显示之前做一个转换。

3. sql注入：将所有增删查改语句中加入了一些恒成立的语句，损坏数据库或泄露数据。防止手段：框架检测语句中的一些有风险的代码。

4. 反爬：防止别人获取你的数据

   防止手段：

    - 服务端限制请求次数，一个IP在一段时间内只能请求一次
    - 验证码：图形验证码防止机器学习
    - 串改html内容：将内容做成iconfont，设置`font-family`字体，设置背景图片`background-position`

5. 对前端安全有什么看法？

6. 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？

   注入攻击中，攻击者给程序提供恶意的输入，解析引擎把恶意输入作为命令或者查询的一部分，顺带着改变了程序执行的流程。

   1. 存储性的和反弹性的XSS？
      - XSS攻击：跨站脚本攻击(Cross-Site Scripting)，攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。
      - 防御方法：过滤特殊字符，HttpOnly 浏览器禁止页面的JS访问带有HttpOnly属性的Cookie
   2. CSRF是为了解决什么问题？

7. 网页验证码是干嘛的，是为了解决什么安全问题。

8. 怎么实现反爬？

9. 安全相关 XSS的反射型是什么，怎么避免