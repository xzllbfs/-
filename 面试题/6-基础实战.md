# 编程题

## 原型

1. 实现new

   1. 创建一个空对象，这个对象将会作为执行构造函数之后返回的对象实例
   2. 将这个空对象的隐式原型指向构造函数的显示原型
   3. 将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑
   4. 如果构造函数返回了一个对象，那么这个对象会取代new出来的结果，否则new函数会自动返回这个新对象

2. 实现call

   1. 把函数作为要改变this的对象的一个成员，确保成员属性的唯一性
   2. 基于目标对象的成员访问执行函数，目标如果不是对象，转换为对象

3. 实现bind

   1. 保存原函数的this指针
   2. 取出第一个参数作为上下文，剩余参数类数组转数组
   3. 返回一个新的函数，新的函数中绑定目标对象并传参，使用apply将this指向目标对象

4. 实现instanceof

5. 实现Object.Create()

   1. 创建一个类，返回这个类的实例
   2. 传递的prototype: 实例.__proto__=类.prototype

6. 实现深拷贝

7. 实现几种js的继承方式

   1. 原型继承
   2. 借用构造函数继承
   3. 对象继承
   4. 寄生式继承
   5. 组合继承
   6. 寄生组合式继承
   7. class 继承

8. 如何让 (a == 1 && a == 2 && a == 3) 的值为true？

   1. 将a设置为一个对象，并自定义一个`toString`方法

   2. 使用`Object.definedProperty`（或者Proxy）数据拦截再处理，拦截到获取a的时候，按对应次数返回1，2，3

9. 如何实现js的沙盒模型

## 对象&数组

1. 实现对象深度冻结

   测试用例：实现一个deepFreeze函数，使得person.profession.name不能再次赋值

      ```js
      let person = {
          name: "Leonardo",
          profession: {
              name: "developer"
          }
      };
      deepFreeze(person);
      person.profession.name = "doctor"; // TypeError: Cannot assign to read only property 'name' of object
      ```

2. 创建代理对象，通过代理对象访问属性时抛出错误 Property "${key}" does not exist

3. 实现map

4. 实现every

5. 实现some

6. 实现filter

7. 实现reduce

8. 实现一个数组的flatten

   1.  利用 Array.prototype.flat
   2. 利用 reduce 和 concat
   3. 使用 stack 无限反嵌套多层嵌套数组

9. 实现数组去重

   1. new Set()
   2. indexOf
   3. includes
   4. reduce
   5. map

## 高阶函数

1. 实现一个sleep函数，两个函数之间的延迟函数

   测试用例：111和222输出间隔时间为2s

   ```js
   function test() {
     console.log('111');
     sleep(2000);
     console.log('222');
   }
   
   test()
   ```

   思路：利用一个伪死循环阻塞主线程

2. 实现once函数，多次调用同一个方法只执行一次

   测试用例：只输出一次5

   ```
   let pay = once(function(money) {
   	console.log(`支付金额：${money}`)
   })
   
   pay(5)
   pay(5)
   pay(5)
   pay(5)
   ```

3. 实现柯里化函数

   测试用例：3次都输出6

   ```js
   function getSum (a, b, c) {
     return a + b + c
   }
   
   const curried = curry(getSum)
   
   console.log(curried(1, 2, 3))
   console.log(curried(1)(2, 3))
   console.log(curried(1, 2)(3))
   ```

4. 实现记忆函数，使得函数执行一次后，再次调用不会返回的是上一次的结果

   测试用例：r只输出了一次

   ```js
   function getArea (r) {
     console.log(r)
     return Math.PI * r * r
   }
   
   let getAreaWithMemory = memoize(getArea)
   console.log(getAreaWithMemory(4))
   console.log(getAreaWithMemory(4))
   console.log(getAreaWithMemory(4))
   ```

5. 实现防抖函数

   函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次

6. 实现节流函数

   函数节流是指一定时间内js方法只跑一次

## 闭包&作用域&this

1. 修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5

   ```js
   for (var i=1; i<=5; i++) {
       setTimeout(function timer() {
           console.log(i)
       }, 1000 )
   }
   ```

   1. 闭包
   2. 立即执行函数
   3. 块级作用域

2. 实现一个缓存函数

   通过闭包隐藏数据

## 异步

1. 红灯3秒亮一次,绿灯1秒亮一次,黄灯2秒亮一次,  如何让三个灯不断交替重复亮灯? 

   1. 亮灯函数，返回promise对象，将SetTimeout写在执行器里
   2. 执行亮灯函数，利用promise.then，红绿黄亮灯方法依次执行，循环往复调用此函数

2. 实现一个异步方法的串行和并行

   测试用例：串行 serialSum，并行 parallelSum

   ```js
   (async () => {
     console.log('Running...');
     const res1 = await serialSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
     console.log(res1)
     const res2 = await parallelSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
     console.log(res2)
     console.log('Done');
   })()
   ```

   思路：

3. 实现一个版本对比的函数，比较版本号大小

4. 随机生成16进制颜色与rgb互转

5. 实现一个数组的排序函数，返回新的数组

## DOM & 事件

1. 编写一个通用的事件委托函数

   ul>li>span，对于这样的dom结构，如果span的点击函数想要委托给li，那么就将ul作为外层事件监听，获取点击的目标元素span，span向上查找到li元素，将目标元素指向给li，所以点击span执行的事件就委托给了li

2. 一次性插入多个DOM节点，考虑性能该如何实现

   思路：将频繁操作改为一次性操作

   实现：创建文档片段，循环插入片段后再将片段插入真实DOM

3. 实现置顶效果，缓慢回到顶部

4. 创建10个`<a>`标签，点击的时候分别弹出对应的序号

5. 实现checkbox全选以及反选

## 网络

1. 对象和url参数的互相转换，分别如何实现？

2. 实现简易的ajax

3. 写一个请求函数，传入一个url，如果请求失败，第一次1s后重试，第二次1.5s后重试，第三次2.25s，第四次不试了

   fetchAPI

4. 实现一个请求函数，传入一个url数组，和并发请求的数量。

# 分析题

1. 运算符优先级

   ```js
   var a = 1;
   var b = 2;
   console.log(a+++b)
   ```

   结果为3，++运算符的优先级高于+运算符，所以先执行a++得到1，然后1+b=3

2. parseInt参数

   `[1,2,3].map(parseInt)`的结果

   代码补全如下：

   ```js
   [1,2,3].map((item, index) => {
     return parseInt(item, index);
   })
   
   parseInt(1, 0)	// 把1当做10进制，转为10进制
   parseInt(2, 1)	// 把2当做1进制，没有在2-36之间，所以转为NaN
   parseInt(3, 2)	// 把3当做2进制，转为10进制，但是2进制只有1，0符合，所以为NaN
   // 1, NaN, NaN
   ```

3. 类型转换

   ```js
   let result = 100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false;
   console.log(result); // NaNTencentnull9false
   
   console.log([]==false);// true
   console.log(![]==false);// true
   ```

   1. 数字+undefined的结果是NaN
   2. 字符串连接值都会转换为字符串

4. 作用域

   ```js
   var x = 1;
   function func(x, y = function anonymous1() {x = 2}) {
       x = 3;
       y();
       console.log(x);
   }
   func(5);
   console.log(x);
   ```

   答案：2，1

   1. `EC(func)`中的`x = 3;`影响`EC(func)`中的形参x
   2. `EC(anonymous1)`中的`x=2`影响  `EC(func)`中的形参x，因为`EC(anonymous1)`并没有x，所以打印2
   3. 最后一个log打印`EC(G)`中的x = 1

5. 变量提升

   ```js
   function sayHi() {
     console.log(name);
     console.log(age);
     var name = "Lydia";
     let age = 21;
   }
   
   sayHi()
   ```

   结果：undefined，ReferenceError

6. this指向问题

   ```js
   var User = {
        count:1,
        action:{
        getCount:function () {
            return this.count
         }
        }
   }
   var getCount = User.action.getCount;
       setTimeout(() => {
       console.log("result 1",User.action.getCount())
   })
   console.log("result 2",getCount())
   ```

   结果：result 2 undefined，result 1 undefined

   1. result 2  中执行的函数getCount()没有执行主体，里面函数的 this 是window，所以打印undefined
   2. result 1 中执行的方法getCount()前面的执行者是action，而action中没有count熟悉，所以打印结果是 undefined。如果想输出1，可以通过`bind(user)`的方式改变this指向

7. 如果.then传入不是函数，后面的then会返回什么

   ```js
   Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)
   ```

   结果是1，.then里面的参数如果不是函数，就会无视它，被替换为val=>val

8. 如果promise的执行器函数，调用了resolve之后紧接着又调用了reject，状态会改变吗？

   ```js
   const promise = new Promise((resolve, reject) => {
     resolve('success')
     reject('error')
   })
   promise.then(res => {
     console.log('then', res)
   }).catch(err => {
      console.log('catch', err)
   })
   ```

   结果为then success，状态只会从pending变为fufilled或rejected