## 分析题

1. 运算符优先级

   ```js
var a = 1;
   var b = 2;
   console.log(a+++b)
   ```
   
   结果为3，++运算符的优先级高于+运算符，所以先执行a++得到1，然后1+b=3
   
2. parseInt参数

   `[1,2,3].map(parseInt)`的结果

   代码补全如下：

   ```js
   [1,2,3].map((item, index) => {
     return parseInt(item, index);
   })
   
   parseInt(1, 0)	// 把1当做10进制，转为10进制
   parseInt(2, 1)	// 把2当做1进制，没有在2-36之间，所以转为NaN
   parseInt(3, 2)	// 把3当做2进制，转为10进制，但是2进制只有1，0符合，所以为NaN
   // 1, NaN, NaN
   ```

3. 类型转换

   ```js
   let result = 100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false;
   console.log(result); // NaNTencentnull9false
   
   console.log([]==false);// true
   console.log(![]==false);// true
   ```

   1. 数字+undefined的结果是NaN
   2. 字符串连接值都会转换为字符串

4. 作用域

   ```js
   var x = 1;
   function func(x, y = function anonymous1() {x = 2}) {
       x = 3;
       y();
       console.log(x);
   }
   func(5);
   console.log(x);
   ```

   答案：2，1

   1. `EC(func)`中的`x = 3;`影响`EC(func)`中的形参x
   2. `EC(anonymous1)`中的`x=2`影响  `EC(func)`中的形参x，因为`EC(anonymous1)`并没有x，所以打印2
   3. 最后一个log打印`EC(G)`中的x = 1

5. 变量提升

   ```js
   function sayHi() {
     console.log(name);
     console.log(age);
     var name = "Lydia";
     let age = 21;
   }
   
   sayHi()
   ```

   结果：undefined，ReferenceError

6. this指向问题

   ```js
   var User = {
        count:1,
        action:{
        getCount:function () {
            return this.count
         }
        }
   }
   var getCount = User.action.getCount;
       setTimeout(() => {
       console.log("result 1",User.action.getCount())
   })
   console.log("result 2",getCount())
   ```

   结果：result 2 undefined，result 1 undefined

   1. result 2  中执行的函数getCount()没有执行主体，里面函数的 this 是window，所以打印undefined
   2. result 1 中执行的方法getCount()前面的执行者是action，而action中没有count熟悉，所以打印结果是 undefined。如果想输出1，可以通过`bind(user)`的方式改变this指向

7. 如果.then传入不是函数，后面的then会返回什么

   ```js
   Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)
   ```

   结果是1，.then里面的参数如果不是函数，就会无视它，被替换为val=>val

8. 如果promise的执行器函数，调用了resolve之后紧接着又调用了reject，状态会改变吗？

   ```js
   const promise = new Promise((resolve, reject) => {
     resolve('success')
     reject('error')
   })
   promise.then(res => {
     console.log('then', res)
   }).catch(err => {
      console.log('catch', err)
   })
   ```

   结果为then success，状态只会从pending变为fufilled或rejected

## 编程题

1. 实现new

   - 创建一个空对象，这个对象将会作为执行构造函数之后返回的对象实例
   -  将这个空对象的隐式原型指向构造函数的显示原型
   - 将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑
   - 如果构造函数返回了一个对象，那么这个对象会取代new出来的结果，否则new函数会自动返回这个新对象

2. 实现简易的ajax

3. 实现深拷贝

4. 实现apply，call

5. 实现bind

   1. 保存原函数的this指针
   2. 取出第一个参数作为上下文，剩余参数类数组转数组
   3. 返回一个新的函数，新的函数中绑定目标对象并传参，使用apply将this指向目标对象

6. 实现Object.Create()

7. 实现map

8. 实现instanceof

9. 实现一个深拷贝

10. 实现一个数组的flatten

11. 实现一个数组的排序函数，返回新的数组

12. 实现柯里化函数

13. 防抖实现方式

    函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次

14. 节流实现方式

    函数节流是指一定时间内js方法只跑一次

15. 实现一个sleep函数

    利用一个伪死循环阻塞主线程

16. 实现对象的深冻结

    ```js
    function deepFreeze(object) {
        let propNames = Object.getOwnPropertyNames(object);
        for (let name of propNames) {
            let value = object[name];
            object[name] = value && typeof value === "object" ?
                deepFreeze(value) : value;
        }
        return Object.freeze(object);
    }
    let person = {
        name: "Leonardo",
        profession: {
            name: "developer"
        }
    };
    deepFreeze(person);
    person.profession.name = "doctor"; // TypeError: Cannot assign to read only property 'name' of object
    ```

17. 实现置顶效果，缓慢回到顶部

18. 编写一个通用的事件委托函数

    ul>li>span，对于这样的dom结构，如果span的点击函数想要委托给li，那么就将ul作为外层事件监听，获取点击的目标元素span，span向上查找到li元素，将目标元素指向给li，所以点击span执行的事件就委托给了li

    ```js
    function eventDelegate(element, eventType, selector, fn) {
      if (fn == null) {
        fn = selector
        selector = null
      }
      element.addEventListener(eventType, event => {
          let target = event.target
          if (selector) {
            while (!target.matches(selector)) {
                if (element === target) {
                    target = null
                    break
                }
                target = target.parentNode
            }
            target && fn.call(target, event)
          } else {
            fn(event)
          }
      })
      return element
    }
    ```

19. 一次性插入多个DOM节点，考虑性能该如何实现

    思路：将频繁操作改为一次性操作

    实现：创建文档片段，循环插入片段后再将片段插入真实DOM

    ```js
    const listNode = document.getElementById('list')
    const frag = document.createDocumentFragment()
    for (let i = 0; i< 10; i++) {
      const li = document.createElement('li')
      li.innerHtml = "list item" + i
      frag.appendChild(li)
    }
    listNode.appendChild(frag)
    ```

20. 设置一个变量a，使得if语句能够执行

    ```
    var a = ?;
    if (a == 1 && a == 2 && a == 3) {
        console.log(1);
    }
    ```

    方式1. 将a设置为一个对象，并自定义一个`toString`方法

       因为隐式类型转换，`==`时会将**对象a**转为字符串再转为数字类型，过程中会调用到对象原型链中的`toString`方法

       ```js
    var a = {
      i: 0,
      toString() {
        return ++this.i
      }
    }
    
    if (a == 1 && a == 2 & a == 3) {
      console.log(1)
    }
       ```

    方式2. 使用`Object.definedProperty`（或者Proxy）数据拦截再处理，拦截到获取a的时候，按对应次数返回1，2，3

       ```js
    var i = 0;
    Object.defineProperty(window, "a", {
      get() {
        return ++i;
      }
    })
    
    if (a == 1 && a == 2 & a == 3) {
      console.log(1)
    }
       ```

21. 创建10个`<a>`标签，点击的时候分别弹出对应的序号

    ```js
    let aDom
    for (let i = 0; i < 10; i++) {
      aDom = document.createElement('a')
      aDom.innerHTML = i + '<br/>'
      aDom.addEventListener('click', function (e) {
        e.preventDefault()
        console.log(i)
      })
      document.body.appendChild(aDom)
    }
    ```

22. 修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5

    ```js
    for (var i=1; i<=5; i++) {
        setTimeout(function timer() {
            console.log(i)
        }, 1000 )
    }
    ```

    方案1：闭包

    ```js
    for (var i = 1; i <= 5; i++) {
      log(i) // 1 2 3 4 5
    }
    function log(i) {
      setTimeout(function timer() {
        console.log(i)
      }, 1000)
    }
    ```

    方案2：立即执行函数

    ```js
    for (var i = 1; i <= 5; i++) {
      (function (i) {
        setTimeout(function timer() {
          console.log(i)
        }, 1000)
      })(i)
    }
    ```

     方案3：块级作用域

    ```js
    for (let i=1; i<=5; i++) {
      setTimeout(function timer() {
        console.log(i)
      }, 1000 )
    }
    ```

23. 实现checkbox全选以及反选

24. 红灯3秒亮一次,绿灯1秒亮一次,黄灯2秒亮一次,  如何让三个灯不断交替重复亮灯? 

    1. 亮灯函数，返回promise对象，将SetTimeout写在执行器里
    2. 执行亮灯函数，利用promise.then，红绿黄亮灯方法依次执行，循环往复调用此函数

25. 写一个请求函数，传入一个url，如果请求失败，第一次1s后重试，第二次1.5s后重试，第三次2.25s，第四次不试了

    fetchAPI

26. 实现异步的串行和并行

    ```js
    // 字节面试题，实现一个异步加法
    function asyncAdd(a, b, callback) {
      setTimeout(function () {
        callback(null, a + b);
      }, 500);
    }
    
    // 1. promisify
    const promiseAdd = (a, b) => new Promise((resolve, reject) => {
      asyncAdd(a, b, (err, res) => {
        if (err) {
          reject(err)
        } else {
          resolve(res)
        }
      })
    })
    
    // 2. 串行处理
    async function serialSum(...args) {
      return args.reduce((task, now) => task.then(res => promiseAdd(res, now)), Promise.resolve(0))
    }
    
    // 3. 并行处理
    async function parallelSum(...args) {
      if (args.length === 1) return args[0]
      const tasks = []
      for (let i = 0; i < args.length; i += 2) {
        tasks.push(promiseAdd(args[i], args[i + 1] || 0))
      }
      const results = await Promise.all(tasks)
      return parallelSum(...results)
    }
    
    // 测试
    (async () => {
      console.log('Running...');
      const res1 = await serialSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
      console.log(res1)
      const res2 = await parallelSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
      console.log(res2)
      console.log('Done');
    })()
    ```

27. 实现一个版本对比的函数，比较版本号大小

28. 创建代理对象,通过代理对象访问属性时抛出错误 `Property "${key}" does not exist`

29. 实现一个请求函数，传入一个url数组，和并发请求的数量。

30. 如何实现js的沙盒模型

31. 对象和url参数的互相转换，分别如何实现？

32. 随机生成16进制颜色与rgb互转

33. 创建代理对象,通过代理对象访问属性时抛出错误 `Property "${key}" does not exist`

```js
const man = {
	name: 'jscoder',
	age: 22
}

const pMan = new Proxy(man, {
	get(target, key){
		if (key in target) {
			return target[key]
		} else {
			throw new Error(`Property "${key}" does not exist`)
		}
	}
})
```

