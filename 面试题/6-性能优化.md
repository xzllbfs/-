## 性能优化

1. 性能优化有哪些方面？

   1. 页面加载速度
   2. 请求响应速度
   
   3. 内存占用
   4. 动画流畅度
   5. 能耗：复杂canvas动画
   
2. 性能优化的手段有哪些？

     1. 关键渲染路径节点优化
     2. 减少http请求次数
     3. 设置各种缓存、预处理、长连接机制
     4. 防抖节流机制
     5. 长列表渲染优化
     6. 图片懒加载

3. 防抖和节流为什么要return 一个函数

4. 页面渲染时js阻塞的解决方法？

   阻塞的原理：浏览器在解析HTML页面是从上到下依次解析、渲染，如果`<head>`中引用了一个a.js文件，浏览器不知道a.js中执行了哪些脚本，会对页面造成什么影响，所以浏览器会等js文件下载并执行完成后才继续渲染，如果这个时间过长，会白屏。

   - 将script标签放在body底部
   - 动态加载script文件
   - script

5. 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？

6. 如何编写高性能的Javascript？

7. 那些操作会造成内存泄漏？

8. 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?

9. **图片懒加载的实现原理？**

   当打开一个有很多图片的页面时，先只加载页面上看到的图片，等滚动到页面下面时，再加载所需的图片。这就是图片懒加载。它的作用是减少或延迟请求数，缓解浏览器的压力，增强用户体验。

   - 设置图片src属性为同一张图片，同时自定义一个data-src属性来存储图片的真实地址
   - 页面初始化显示的时候或者浏览器发生滚动的时候判断图片是否在视野中
   - 当图片在视野中时，通过js自动改变该区域的图片的src属性为真实地址

10. 说一下V8的垃圾回收机制 （小米）

   主要思路：

   1. 新生代内存区分为两个等大小空间，使用空间为From，空闲空间为To
   2. 将所有对象存储于From空间（包括活动对象和非活动对象）
   3. 当From空间应用到一定程度后会触发GC机制，标记整理后将活动对象拷贝至To
   4. From完成释放（From和To交换空间）

   采用分代回收思想，v8内存空间一分为二

   小空间用于存储新生代对象，回收新生代采用**复制算法+标记整理**，新生代内存区分为两个大小相等的空间：使用空间为Form,存储活动对象。空闲空间为To,标记整理后将活动对象拷贝至To空间,最后From和To交换空间完成释放。

   大空间用于存储老生代对象,回收老生代采用 **标记清除+标记整理+增量标记算法：首先使用标记清除算法完成垃圾空间的回收,相对空间碎片问题,速度提升比较明显。标记整理针对的是新生代晋升老生代时,老生代内存空间不足的对象，最后会采用增量标记算法进行效率优化。

11. performance API 中什么指标可以衡量首屏时间？

   1）performance.timing

   - performance.timing.loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳,如果该事件还没有发生,返回 0。
   - performance.timing.navigationStart:当前浏览器窗口的前一个网页关闭,发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页,则等于 fetchStart 属性。

   ```js
     var t = performance.timing;
     // 首屏渲染时间
     var pageLoadTime = t.loadEventEnd - t.navigationStart;
   ```

   2）在vue的mounted生命周期中调用`performance.now()`得到当前网页 从`performance.timing.navigationStart` 到 当前时间的的 微秒数。

11. 性能优化
    https://www.cnblogs.com/wang-z-z/p/9485887.html

    1. 技术点
           1) PWA: Progressive Web Apps, 渐进式Web应用开发
           2) Lighthouse: 自动化测试工具
           3) SSR: Server Side Rendering, 服务端渲染
           4) NSR: Native Side Rendering, 客户端提前渲染
           5) Rehydration: 注水
       
    2. 优化技术的发展
           1) 2007年 - 雅虎军规、YSlow
           2) 2008年 - WebPageTest开源
           3) 2009年 - SPDY开始实验
           4) 2010年 - Facebook提出BigPipe
           5) 2012年 - HTTP/2提案、gQUIC初版规范提出
           6) 2015年 - 发布HTTP/2标准、RAIL性能模型、PageSpeed Insights
              (1) RAIL模型
                 Response - 100ms相应用户输入后
                 Animation - 每帧动画在16ms内完成
                 Idle - 最大化空闲时间
                 Load - 3G中等设备5s内可交互
                 为什么是50ms?
                   100ms = 50ms + 50ms
                   超过50ms被定义为long task
           7) 2016年 - PWA概念提出、Lighthouse开源
           8) 2017年 - PWA被迅速采用、AMP推出
           9)  2018年 - HTTP/3正式启用
           10) 2020年 - Web Vitals开始推广
       
    3. 性能优化的指标
           1) FP - 首次绘制(First Paint)
           1) FCP - 初次内容绘制时间(First Contentful paint)
           2) LCP - 最大内容绘制时间(Largest Contentful paint)
           3) FID - 首次输入后延迟(First Input delay)
           4) TTI - 页面可交互时间(Time To Interactive)
           5) TBT - 主线程累计阻塞时间(Total Blocking time)
           6) CLS - 累计布局偏移(Cumulative layout shift)
       
    4. 性能指什么?
           1) 加载速度
           2) 响应速度
           3) 动画流畅度
           4) 能耗
           5) 内存占用
       
    5. 常见的优化手段
           1) 缓存技术
              (1) 通用优化
                 * 使用CDN加速静态资源
                           * 合理设置缓存时间 Cache-Control
                 * 避免注册unload以影响前进后退缓存
                     (2) 前端最佳实践
          * 使用异步的Cache API/IndexDB
               e API主要存储HTTP请求,其他存储IndexDB
          * 尽量避免同步的LocalStorage, ~5M
               端的优化
          * 提供离线包,提前下发资源
               虑将离线包的资源预置进HTTP Cache

    9. 进一步考虑主文档、关键路径资源预置到Memory Cache
          技术
          
          ```html
          <link rel="dns-prefetch" href="//example.com">
          <link rel="preconnect" href="//example.com">
          <link rel="preconnect" href="//cdn.example.com" crossorigin>
          <link rel="prefetch" href="//example.com/next.html" as="document"
                crossorigin="use-credentials">
          <link rel="prefetch" href="/library.js" as="script">
          <link rel="prerender" href="//example.com/next-page.html">
          <link rel="preload" href="/styles/other.css" as="style">
          ```
          
          ​    3) 渲染方案
          ​       (1) 静态渲染 Static Rendering (SR)
          ​       (2) 前端渲染 Client Side Rendering (CSR)
          ​       (3) 服务端渲染 Server Side Rendering (SSR)
          ​       (4) 客户端渲染 Native Side Rendering (NSR)
          浏览器API
          ​    1) API类别
          ​      (1) Navigation Timing - ⻚⾯导航性能
          ​      (2) Resource Timing - ⼦资源加载性能
          ​      (3) Paint Timing - FP/FCP
          ​      (4) Element Timing - ⾃定义 LCP
          ​      (5) Event Timing - FID
          ​      (6) Layout Instability API - CLS
    ​      (7) Long Tasks API - ⻓任务优化
          ​      (8) Frame Timing - 慢帧优化
          ​    2) Performance Timeline
          ​      (1) Hight Resolution Time
          
             * performance.now()
                  formance.timeOrigin
                   * performance.toJSON()
                      (2) 三个接口
             * getEntries()
                  EntriesByType()
             * getEntriesByName()
                  个对象
             * PerformanceEntry
                  rformanceObserver
                        new PerformanceObserver((entryList) => {
                          for (const entry of entryList.getEntries()) {
                  console.log('LCP candidate', entry.startTime, entry)
                          }
                        }).observe({
                          type: 'largest-contentful-paint',
                          buffered: true
                        })
                      3) Navigation Timing
                         (1) performance.timing
                  startTime
                  unloadEventStart
                  unloadEventEnd
                  redirectStart
                  redirectEnd
                  fetchStart
                  domainLookupStart
                  domainLookupEnd
                  connectStart
                  secureConnectionStart
                  connectEnd
                  requestStart
                  responseStart
                  responseEnd
                  domInteractive
                  domContentLoadedEventStart
                  domContentLoadedEventEnd
                  domLoading
                  domComplete
                  loadEventStart
                  loadEventEnd
                         (2) performance.navigation.type
                         (3) performance.navigation.redirectCount
                         enum NavigationType {
                           "navigate",
                           "reload",
                           "back_forward",
                           "prerender"
                         }
                      4) Resource Timing
                          (1) performance.getEntriesByType('resource')
                  Timing-Allow-Origin
                      5) Paint Timing
                          (1) 收集FP, FCP两个指标
                  name: first-paint
                  name: first-contentful-paint
                          new PerformanceObserver((entries) => {
                  const prefEntries = entries.getEntries()
                  for (let i = 0; i < prefEntries.length; i++) {
                  console.log(prefEntries[i])
                  }
                          }).observe({
                  type: 'paint',
                          })
                      6) Event Timing
                         new PerformanceObserver((entries, observer) => {
                          const firstInput = entries.getEntries()[0]
                          const inputDelay = firstInput.processingStart - firstInput.startTime
                          // Report inputDelay to analytics
                          observer.disconnect()
                        }).observe({
                          type: 'first-input',
                          buffered: true
                        })
                      7) Frame Timing
                        { entryTypes: ['frame'] }
                      8) Long Tasks API
                         1) Long Task > 50ms
                        { entryTypes: ['longtask'] }

## 体验优化

1. 单页面程序如何做SEO？
2. 写代码的时候应该注意哪些SEO问题？

## 题海

1. 页面编码和被请求的资源编码如果不一致如何处理？

2. 服务器代理转发时，该如何处理cookie?

3. 什么是RPC？

4. webSocket如何兼容低浏览器？

5. 怎么用get实现post，就是使用get方法但是参数放到request body中

6. WebSocket 是什么原理？为什么可以实现持久连接？

7. xhr.readyState请求状态码有哪些？分别代表什么意思？

   - 0-未初始化：还没有调用send()方法
   - 1-载入：已调用send()方法，正在发送请求
   - 2-载入完成：send方法执行完成，已经接收到全部响应内容
   - 3-交互：正在解析响应内容
   - 4-完成：响应内容解析完成，可以在客户端调用

8. 介绍一下你对浏览器内核的理解？常见的浏览器内核有哪些？

9. 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?

   渲染引擎Webkit

   执行引擎V8

10. 浏览器是怎样解析CSS选择器的？

11. performance API 中什么指标可以衡量首屏时间

12. 检测浏览器版本有哪些方式？

13. 什么是浏览器的同源策略？

14. title与h1的区别、b与strong的区别、i与em的区别？

    title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；

    `<strong><em>`标于相比与 `<b><i>` 标签更加侧重标签语义化，容易被搜索引擎抓取。应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。

    - 自然样式标签（Physical Style Elements）： b, i, u, s, pre
    - 语义样式标签（Semantic Style Elements）：strong, em, ins, del, code

15. meta标签有哪些常见属性？

    **charset**属性：定义网页文档的字符集

    ```html
    <meta charset="utf-8" />
    ```

    **name+content**属性：

    | 名称        | 描述                                                         |
    | ----------- | ------------------------------------------------------------ |
    | viewport    | 用户网页的可视区域，即“视区”，优化移动浏览器的显示。         |
    | keywords    | 网页关键词，描述该网页内容的一组唯一的关键字，内容不应超过 874 个字符 |
    | robots      | 搜索引擎索引方式，`robotterms`是一组使用逗号(,)分割的值，通常有如下几种取值：`none`，`noindex`，`nofollow`，`all`，`index`和`follow`。确保正确使用`nofollow`和`noindex`属性值。 |
    | author      | 网页作者                                                     |
    | website     | 网页地址                                                     |
    | copyright   | 网页版权信息                                                 |
    | description | 网页描述，准确反映网页内容的描述标签，内容不能超过 150 个字符 |
    | renderer    | 指定双核浏览器默认以何种方式渲染页面                         |
    | minimal-ui  | iOS 7.1Safari新增，在网页载入时默认隐藏地址栏与导航栏。      |

    ```html
    <!-- 网页作者 -->
    <meta name="author" content="开源技术团队"/>
    <!-- 网页地址 -->
    <meta name="website" content="https://sanyuan0704.github.io/frontend_daily_question/"/>
    <!-- 网页版权信息 -->
     <meta name="copyright" content="2018-2019 demo.com"/>
    <!-- 网页关键字, 用于SEO -->
    <meta name="keywords" content="meta,html"/>
    <!-- 网页描述 -->
    <meta name="description" content="网页描述"/>
    <!--浏览器渲染内核-->
    <meta name="renderer" content="webkit">
    <!--
    	webkit:页面用极速内核
      ie-comp：ie兼容内核
      ie-stand：ie标准内核
    -->
    <!-- 移动端常用视口设置 -->
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <!-- 
      viewport参数详解：
      width：设置 viewport 的宽度，正整数/字符串 device-width
      height：设置 viewport 的高度，正整数/字符串 device-height
      initial-scale：设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数
      maximum-scale：设置最大缩放系数，0.0-10.0之间的正数
      minimum-scale：设置最小缩放系数，0.0-10.0之间的正数
      user-scalable：如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no
     -->
    <meta name="robots" content="index,follow" />
    <!--
        all：文件将被检索，且页面上的链接可以被查询；
        none：文件将不被检索，且页面上的链接不可以被查询；
        index：文件将被检索；
        follow：页面上的链接可以被查询；
        noindex：文件将不被检索；
        nofollow：页面上的链接不可以被查询。
     -->
    ```

    **http-equiv+content属性**：

    ```html
    <!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 -->
    <meta http-equiv="expires" content="Fri, 12 Jan 2020 18:18:18 GMT"/>
    <!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 -->
    <meta http-equiv="refresh" content="1; url=https://www.baidu.com"/>
    <!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 -->
    <meta http-equiv="pragma" content="no-cache"/>
    <!-- 也是设置cookie的一种方式，并且可以指定过期时间 -->
    <meta http-equiv="set-cookie" content="name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/"/>
    <!-- 使用浏览器版本 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    ```

16. 怎么防止移动端页面缩放？

    1）meta标签

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    ```

    2）iOS 10之后不接受meta标签，可通过js监听手势控制：

    ```js
    document.addEventListener('gesturestart', function (event) {
        event.preventDefault()
    })
    ```

17. 页面导入样式时，使用link和@import有什么区别？

    - 形式上的区别：`link`属于XHTML标签，`@import`完全是CSS提供的一种方式。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，`@import`就只能加载CSS了。
    - 兼容性区别：由于`@import`是CSS2.1提出的，所以老的浏览器不支持，`@import`只有在IE5以上的才能识别，而link标签无此问题。
    - 加载顺序区别：当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而`@import`引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览`@import`加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。在使用webpack预编译的时候，extract-text-webpack-plugin会生成新的CSS文件。
    - dom控制样式时的区别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为`@import`不是dom可以控制的。

18. 什么是FOUC？你如何来避免FOUC？

    FOUC：文档样式短暂失效(Flash of Unstyled Content)的简称，浏览器以无样式显示页面内容的瞬间闪烁现象。

    场景：

    - 使用import方法导入样式表
    - 将样式表放在页面底部
    - 多个样式表放在HTML的不同位置

    原因：当样式表晚于结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。

    解决方案：使用link标签将样式表放在文档head中

19. 把`<script>`标签放在`</body>`之前和之后有什么区别？浏览器会如何解析它们？

    按照HTML5标准中的HTML语法规则，如果在`</body>`后再出现`<script>`或任何元素的开始标签，都是parse error，浏览器会忽略之前的`</body>`，即视作仍旧在body内。所以实际效果和写在`</body>`之前是没有区别的。

    浏览器解析时，所有标签都会解析进这 head 和body两个标签里边。body之前的任何位置都会解析进head里边，之后的都会解析进body里边。

20. 怎么实现script的异步加载？

    - 标签加上defer或async：两者的区别在于脚本加载完成之后何时执行，如果存在多个有defer属性的脚本，那么它们是按照加载顺序执行脚本的；而对于async，它的加载和执行是紧紧挨着的，无论声明顺序如何，只要加载完成就立刻执行，它对于应用脚本用处不大，因为它完全不考虑依赖。

    - 异步加载JS

      ```js
      getMap.onclick = function(){
         //获得需要插入的位置
         var oDiv = document.getElementById('div');
         //异步创建script
         var script = document.createElement('script');
      
         script.src = 'https://map.baidu.com/...'
      
         oDiv.appendChild(script)
       }
      ```

    - 通过 ajax 去获取 js 代码，然后通过 eval 执行

      ```js
      window.onload = function(){
          //1.创建XMLHttpRequest对象并考虑兼容性
          var xhr;
          if(window.XMLHttpRequest){
              //通用浏览器
              xhr = new XMLHttpRequest()
          }
          else{
              //IE5/6
              xhr = new ActiveXObject('Miscrosoft.XMLHttp')
          }
          
          //2.设置请求方式
          let url = ''
          xhr.open('get', url, true);//异步请求
          
          //3.发送请求
          xhr.send()
          
          //4.回调函数
          xhr.onreadyStateChange = function(){
              if(xhr.readyState == 4 && xhr.status == 200){
                  let script = xhr.responseText;
                  eval(script)   //异步加载script
              }
          }
      }
      ```

    - 创建并插入 iframe，让它异步执行 js

      ```js
      var iframe = document.createElement('iframe')
       document.body.appendChild(iframe)
       var doc = iframe.contentWindow.document
       doc.open().write('<body onload="insertJS()">')
       doc.close()
      ```

21. preload和prefetch的区别？

    浏览器资源加载优先级总共分为五级：very-high、high、medium、low、very-low，其中MainRescource页面、CSS、字体这三个的优先级是最高的，然后就是Script、Ajax这种，而图片、音视频的默认优先级是比较低的，最低的是prefetch预加载的资源。

    prefetch：有时候你可能需要让一些资源先加载好等着用，例如用户输入出错的时候在输入框右边显示一个X的图片，如果等要显示的时候再去加载就会有延时，这个时候可以用一个link标签：

    ```html
    <link rel="prefetch" href="image.png">
    ```

    preload：在早期浏览器，script资源是阻塞加载的，当页面遇到一个script，那么要等这个script下载和执行完了，才会继续解析剩下的DOM结构，也就是说script是串行加载的，并且会堵塞页面其它资源的加载，这样会导致页面整体的加载速度很慢，所以早在2008年的时候浏览器出了一个**推测加载策略**，即遇到script的时候，DOM会停止构建，但是会继续去搜索页面需要加载的资源，如看下后续的html有没有img/script标签，先进行预加载，而不用等到构建DOM的时候才去加载。这样大大提高了页面整体的加载速度。

22. iframe有哪些优缺点？

    iframe的优点：

    - 方便快捷，可以做多个页面的统一风格的头尾
    - 如果遇到加载缓慢的第三方内容（如图标和广告），这些问题可以由iframe来解决。

    iframe的缺点：

    - 会产生很多页面，不容易管理。
    - 用户体验差：框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力。
    - 不利于SEO：搜索引擎爬虫还不能很好的处理iframe中的内容
    - 兼容性差：很多的移动设备（PDA 手机）无法完全显示框架
    - iframe框架页面会增加服务器的http请求，对于大型网站是不可取的

23. HTML5与之前版本区别？

  - **文档类型声明方式**

  ```html
  <!DOCTYPE html>
  <mete charset="UTF-8">
  ```

  - **新增元素和属性**：布局、表单、音频视频

  - **更加适应时代要求**：移动互联网时代相比pc时代更加迫切希望有一个统一的标准。之前由于各个浏览器不统一，因为修改浏览器兼容引起的bug浪费了大量的时间。在HTML5中视频、音频、图像、动画都会标准化，会解决浏览器兼容这个令人头疼的问题。

2. 如何处理HTML5新标签的浏览器兼容问题？

   - 使用静态资源的html5shiv，在`<head>`中调用以下代码：

     ```html
     <!--[if lt IE9]>
     <script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
     <![endif]-->
     ```

   - 使用skill IE6:， 在`</body>`之前调用以下代码

     ```html
     <!--[if lte IE 6]>
       <script src="http://letskillie6.googlecode.com/svn/trunk/letskillie6.zh_CN.pack.js"></script>
     <![endif]-->
     ```

   - 载入后，初始化新标签的css

     ```css
     header, section, footer, aside, nav, main, article, figure { display: block; }
     ```

   - IE6/IE7/IE8支持通过 `document` 创建标签，利用这一特性让这些浏览器支持HTML5新标签

3. html5有哪些新特性、移除了那些元素？

   **新特性**

   **布局语义化标签**

   - **section**：表示页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分。它可以与h1、h2、h3、h4、h5、h6等元素结合起来使用标记文档结构。

   - **article**：表示页面中的一块与上下文不相关的独立内容，例如博客中的一篇文章。

   - **aside**：表示article元素内容之外的，与article元素相关的辅助信息。

   - **header**：表示页面中一个内容区块或整个页面的标题。

   - **hgroup**：用于整个页面或页面中一个内容区块的标题进行组合。

   - **footer**：用于整个页面或页面中一个内容区块的脚注。一般来说，它会包含创作者的姓名，创建日         期及创作者联系信息。

   - **nav**：表示页面中导航链接的部分。

   - **figure**：表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元，使用figcaption元素        为figure元素组添加标题。

     ![](https://upload-images.jianshu.io/upload_images/2355059-ff64e4b088393e84.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

   **form表单属性**

   - **form**：在html4中，表单内的从属元素必须书写在表单内部，但在html5中，可以书写在表单上任何位置，只需要给该元素制定一个form属性，属性值为表单的id就可以了，这样做的好处是给页面中的元素添加样式时更方便。
   - **formaction**：在html4中，表单内的所有元素都只能通过表单的action属性统一提交到另一个页面，但在html5中可以给所有的提交按钮都增加不同的formaction属性，使得点击不同的按钮，将表单提交到不同的页面。
   - **formmethod**：可以使用formmethod属性来对每个表单元素分别指定不同的提交方法。
   - **placeholder**：当文本框“text”或“textarea”处于未输入状态时文本框中显示的输入提示。
   - **autofocus**：当页面刚打开，文本框、选择框或按钮可以自动获得焦点。不过一个页面只能有一个控件使用该属性。
   - **list**：该属性需要和datalist元素（html5新增）一起使用，list属性的值就是datalist的id，使用datalist元素设置一个选择列表，当用户输入的值在列表中就出现选择提示，当用户想要设定的值不在选择列表之内时，允许其自行输入
   - **autocomplete**：可以指定“on”、“off”和“”三种值，不指定时，使用浏览器默认值。

   **视频和音频**：video、audio 

   **canvas画布**：图形容器、必须使用js脚本来绘制图形

   **移除的元素**：默认字体`<basefont>`、字体标签`<font>`、水平居中`<center>` 、下划线 `<u>`

4. HTML5的form如何关闭自动完成功能？

   - 在IE的Internet选项菜单里的内容--自动完成里面设置
   - 设置form的autocomplete为"off"来关闭form中所有输入框的自动完成功能
   - 设置input的autocomplete为"off"来关闭该输入框的自动完成功能

5. 页面可见性（Page Visibility API） 可以有哪些用途？

   Page Visibility API由以下三部分组成：

   - document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）

   - document.visibilityState：表示下面 4 个可能状态的值

     - hidden：页面在后台标签页中或者浏览器最小化，当浏览器最小化、切换tab、电脑锁屏时发生
     - visible：页面在前台标签页中，用户正在查看当前页面时发生
     - prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true，文档加载离屏或者不可见发生
     - unloaded：页面正在从内存中卸载，当文档将要被unload时发生

   - Visibilitychange事件：当文档从可见变为不可见或者从不可见变为可见时，会触发该事件

     ```js
     document.addEventListener('visibilitychange', function() {
     	console.log(document.visibilityState)
     }
     ```

   用途：当浏览器切换标签页的时候动画或者视频暂停播放，切换回来又继续播放动画或视频，可以使用Visibilitychange监测变化

6. 怎么实现图片压缩上传？fileReader API

   参考链接：

   1. https://www.imooc.com/article/72053
   2. https://www.cnblogs.com/hutuzhu/p/5265023.html

   

7. 什么是PWA？怎么实现PWA

   原文地址：https://segmentfault.com/a/1190000012353473

   PWA全称Progressive Web App，**即渐进式web应用**。一个PWA应用首先是一个网页，可以通过Web技术编写出一个网页应用。随后添加上App Manifest和Service Worker来实现PWA的安装和离线等功能，使得Web应用渐进式接近原生APP

   App Manifest：**Web应用程序清单**在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是**将Web应用程序安装到设备的主屏幕**，不需要用户通过应用商店，伴随着其他功能, 比如离线可用和接收推送通知，为用户提供更快的访问和更丰富的体验。

   Service Worker：Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。

   解决了哪些问题？

   - 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏
   - 实现离线缓存功能，即时用户手机没有网络，依然可以使用一些离线功能
   - 实现了消息推送