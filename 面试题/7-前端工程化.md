# 前端工程化

1. 如何理解前端工程化？

   前端工程化的主要目的为了**提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间**。前端工程化需要从四点做起：模块化，组件化，规范化和自动化

   - 模块化：将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载
   - 组件化：将UI页面拆分成由**模板html+样式css+逻辑js**组成的功能单元，称为组件。组件化不等于模块化，模块化是在资源和代码方面对文件的拆分，而组件化是在UI层面进行的拆分。
   - 规范化：js规范，css规范，前后端接口规范，命名规范，git规范，这都会大大提升开发效率。
   - 自动化：让简单重复的工作交给机器完成，例如自动化测试，自动化部署，自动化构建，持续集成等。

2. 模块化规范：CMD，AMD，CommonJS，ESM的区别？

   - AMD：通过模拟script标签的方式实现模块定义和使用，支持js动态导入。AMD的**define方法**有三个入参—模块名称、依赖模块、模块定义函数，通过`return`方式导出成员。**Require.js**实现了AMD规范。

   - CMD规范：与AMD规范的原理是一样的，CMD的define方法只有一个入参—模块定义函数，通过`exports`或`module.exports`方式导出成员。**Sea.js**实现了CMD规范。

   - CommonJS规范：一个文件就是一个模块，每个模块都有单独的作用域，通过module.exports导出成员，通过require函数载入模块。**NodeJS**实现了CommonJS规范。

   - ES Modules规范：ECMAScript中定义的一套最新的模块系统，设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6定义了ESM规范。

   **对比**

   1. AMD和CMD在定义模块上有区别，AMD提供了模块依赖注入和控制反转功能，CMD没有这功能，导出方式类似于CommonJs。
   2. 静态/动态
      - AMD/CMD和ESM是异步模式加载模块，有一个独立的模块依赖的解析阶段。
      - CommonJs是同步模式加载模块，加载过程阻塞代码执行
   3. 运行时和编译时
      - AMD/CMD 和 CommonJs 是动态引入，运行时引入。不支持 tree-shaking；
      - ESM 是静态引入，编译时引入，必须放在最外层。支持 tree-shaking

3. Babel是如何编译代码的

   Babel编译的核心原理是**使用AST抽象语法树对源码进行分析并转为目标代码**。

   - 通过IIFE立即执行函数实现块级作用域，给块内的变量重新命名
   - 对const声明的变量，只要检测到变量二次赋值，就会通过只读函数抛出错误
   - 对于for循环中let声明的变量，Babel使用闭包保存每一个循环变量i的值
   - 对于箭头函数的转换，就是将当前环境下的this存储起来，在函数内调用
   - 对于async的转换，

4. package.lock.json的作用是什么？

5. webpack打包的过程？

   - 根据`entry`找到打包入口文件，根据`import，require`等推断依赖资源模块，解析出依赖关系树
   - 递归依赖树，找到每个节点对应的资源文件
   - 资源文件根据`moudles.rules`找到`loader`(文件加载器)，通过loader加载对应的资源模块
   - 最后将加载结果打包成bundle.js

6. tree-shaking的原理是什么？

   摇树，摇掉代码中未引用部分（dead-code），tree shaking 不是指某个配置选项,是一组功能搭配使用后的优化效果。它的前提是ES Modules，由webpack 打包的代码必须使用ESM方式实现模块化。

   对`tree-shaking`的检测：通过 `package.json` 的 `sideEffects` 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。

   optimization配置：

   - `usedExports:true`：用来标记未引用代码，打包结果中只会导出被使用的成员
   - `minimize:true`：开启代码压缩用来删除未被使用成员

7. webpack中hash有几种配置方式？

   当我们部署前端的资源文件时，都会启用服务器的静态资源缓存，这样浏览器客户端就可以缓存静态资源，提升响应速度。但是如何缓存过期时间设置的特别短没有效果，过长不能及时更新。为了解决这个问题，webpack在生产模式下给文件名添加hash值的方式，一旦资源发生改变，文件名称也可以跟着一起变化。对于客户端而言，全新的文件名就是全新的请求，就没有缓存的问题。

   - 项目级别—hash：`[name]-[hash].bundle.css`，任何改动全部重新生成
   - 模块级别—chunkhash：`[name]-[chunkhash].bundle.css`，只会重新生成代码模块对应chunk的文件
   - 文件级别—contenthash：`[name]-[content].bundle`，只会重新代码生成对应的文件，比如更新js不会更新css

8. webpack中loader和plugin的区别？

   loader：文件加载器，加载资源的过程类似于工作管道，只是单纯的文件转换过程，将所有的资源以及依赖转换为js模块并加载。

   plugin：扩展器，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于钩子事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。

9. 有没有自定义过plugin和loader？

   自定义loader

   - 实现：导出一个；函数，负责处理加载的资源，输入是资源文件的内容，输出是加工后的结果（必须是js代码）
   - 使用：在webpack.config.js中，将loader文件路径配置到module.rules.use上

   自定义plugin：通过**在生命周期的钩子函数中挂载函数实现扩展**。首先返回一个函数或者包含`apply`方法的对象，apply接收一个`compiler`对象作为参数，compiler有很多钩子函数，比如emit是在输出文件之前执行，钩子函数的入参`compilation`为此次打包的执行上下文。

10. 前端工程化中各个工具的区别

   11. webpack更适合开发应用程序，rollup更适合开发一个框架或者类库。

   12. rollup只是一个**ESM的打包器**，会自动开启**tree shaking**，插件是Rollup唯一的扩展途径 ，模块最终都被打包到一个函数中，无法实现HMR模块热替换。

   13. gulp强调的是开发的工作流程，是基于流的自动化构建工具。webpack强调的是模块化开发，是一个模块化打包工具

   14. grunt构建过程是基于临时文件实现的，所以构建速度相对较慢。gulp的构建过程是基于内存实现的，对文件处理环节都是在内存中完成的，相对于磁盘读写速度更快一些。

15. webpack如何做优化？应用场景有哪些？

16. CI/CD是什么？前端怎么实现CI/CD？

17. 如何实现前端代码的规范化？

    eslint，stylelint，html

    辅助工具：git hook，hasky

18. css中scope和deep的原理

19. wepack如何配置资源的cdn路径

## Babel

1. ES6是如何实现编译成ES5的？Babel是如何编译代码的？

   Babel编译的核心原理是使用AST抽象语法树对源码进行分析并转为目标代码。

   - 通过IIFE立即执行函数实现块级作用域，给块内的变量重新命名
   - 对const声明的变量，只要检测到变量二次赋值，就会通过只读函数抛出错误
   - 对于for循环中let声明的变量，Babel使用闭包保存每一个循环变量i的值
   - 对于箭头函数的转换，就是将当前环境下的this存储起来，在函数内调用

2. 什么是polyfill？有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？

3. babel的缓存是怎么实现的

## 模块化

1. RequireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何避免循环引用？如何 缓存的？）
2. AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）、CommonJS规范区别？
3. JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？

## 工具

1. gulp自己写过任务吗？说一下它的构建流程（阿里2018）
2. webpack 常用配置项，并说明用途  （跟谁学 2020）
3. 阐述 webpack css-loader 作用 和 原理？ （跟谁学）
4. webpack中loader和plugin的区别 （字节跳动 搜狐）
5. webpack、rollup、parcel优劣？
6. webpack 中 tree shaking 的用途和原理是什么？
7. Webpack热更新实现原理?
8. Webpack hash和chunkhash的区别
9. Webpack实现动态加载
10. 自己有没有写过ast, webpack通过什么把公共的部分抽出来的，属性配置是什么
11. webpack怎么配置mock转发代理，mock的服务，怎么拦截转换的
12. webapck的plugin和loader的编写， webapck plugin和loader的顺序
13. webpack的打包构建优化，体积和速度
14. DLLPlugin原理，为什么不直接使用压缩版本的js
15. webapck的HMR，怎么配置：

- 浏览器是如何更新的
- 如何做到页面不刷新也就就自动更新的
- webpack-dev-server webapck-dev-middleware

## 优化

4. 对 tree-shaking 的了解
5. vue-loader 的实现原理是什么？
6. css-loader的原理？

## 其它

1. package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明
2. babel.config.js 和 .babelrc 有什么区别
3. 如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?
4. lerna主要解决什么问题？