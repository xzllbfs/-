# 基础

## Js

1. 数据类型有哪些？

   基本数据类型：boolean，string，number，undefined，null，symbol

   引用数据类型：对象

   - 原生对象：内置对象（包装类：Symbol，Number，Boolean，String）和arguments
   - 宿主对象：浏览器环境对象（window，document等）NodeJs环境对象（global等）
   - 引擎扩展对象：XML，Script等

2. 数据类型判断的方式

   - typeof 操作符：判断基本类型的数据，但是typeof null 返回的是“object” ，因为null表示一个空对象指针
   - instanceof 运算符：用来判断数据是否是某个对象的实例，返回一个布尔值。缺点：不能直接判断基本数据类型；不能判断null和undefined；不能区分数组和对象；判断必须在当前页面声明。
   - constructor：与instanceof 类似，查看目标构造函数，也可以进行数据类型判断。但是不能判断 null 和 undefined，因为这两个特殊类型没有其对应的包装对象
   - Array.isArray()：为了解决instanceof当前页声明的问题，判断数组是否为数组
   -  Object.prototype.toString：toString()方法是定义在Object的原型对象Object.prototype上的，Object的每个实例化对象都可以共享Object.prototype.toString()方法，可以说Object.prototype.toString.call(xxx) 是类型判断的终极解决方案

3. instanceof的实现原理

   用来检测某个实例对象的原型链上是否存在构造函数的 prototype 属性。判断实例对象的隐式原型`__proto__`是否等于构造函数的显示原型`prototype`，如果相对返回`true`，否则**递归向上查找**至原型链顶端，如果都不相等，返回`false`

4. 如何判断一个对象是否为数组？

   ```js
   // 1.判断是否属于数组实例
   [] instanceof Array === true
   // 2. 通过对象的原型方法判断
   Object.prototype.toString.call(arr) // es3
   // 3. 判断值是不是数组
   Array.isArray([])
   // 4. constructor
   [].constructor === Array
   ```

5. new的实现原理

   - 创建一个空对象，这个对象将会作为执行构造函数之后返回的对象实例
   - 将这个空对象的隐式原型（`__proto__`）指向构造函数的显示原型（ `prototype`）
   - 将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑
   - 根据构造函数执行逻辑，如果构造函数返回了一个对象，那么这个对象会取代 new 出来的结果，否则 new 函数会自动返回这个新对象

6. 事件循环是怎么回事？

   主线程读取任务队列中事件的过程是循环不断的，所以这种运行机制又称为Event Loop（事件循环）。

   - 主线程：代码执行的线程。JavaScript是单线程的，但是浏览器不是单线程的，或者说js调用的某些浏览器内部API不是单线程的，例如setTimeOut计时器
   - 任务队列：一个事件的队列，执行任务的时候需要排队，所以形成了任务队列。IO设备完成一项任务，就在任务队列中添加一个事件，表示相关的异步任务可以进入**执行栈**了

7. 宏任务和微任务的区别？

   事件循环用两个队列来处理异步任务。以setTimeout为代表的任务被称为宏任务，放到宏任务队列中，而以Promise 为代表任务被称为微任务，放到微任务队列中。

   事件循环对这两个队列的处理逻辑也不一样，一次事件循环会处理**一个宏任务**和所有**这次循环中产生的微任务**。

   - JavaScript引擎首先从宏任务队列中取出第一个任务
   - 执行完毕后，将微任务队列中的所有任务取出，按顺序全部执行（执行当前微任务和执行过程中产生的微任务）
   - 然后再从宏任务队列中取出下一个， 执行完毕后，再次将微任务队列中的全部取出； 
   - 循环往复，直到两个queue中的任务都取完

8. 什么是作用域？

   标识符（变量）在程序中的可见性范围。作用域是按照具体规则维护标识符的可见性，以确定当前执行的代码对这些标识符的访问权限。作用域是在具体的作用域规则之下确定的。

9. 闭包的原理？

   一段代码丢给了浏览器，**编译阶段**编译器先进行词法分析，创建**词法作用域**和**变量对象** Variable Object（简称VO），同时会进行变量/函数提升。然后将代码转换成**词法单元**，生成**抽象语法树**（AST），最后解析AST后生成浏览器识别的代码，然后这段代码就丢给了执行环境执行。

   在**执行阶段**，解释执行全局代码、调用函数等都会创建并进入一个新的**执行环境**，而这个执行环境被称之为**执行上下文**。执行上下文包含了变量对象，作用域链及this指向等属性。其中变量对象转换成了**活动对象**Active Object（简称AO），然后当前执行环境的变量对象和所有外层已经完成激活的活动对象组成了**作用域链**，作用域链的查找规则遵循**LHS规则**，这个规则规定了如果未在当前作用域中找到变量，则继续向上查找直到全局作用域。执行上下文会被压入执行环境栈，即**入栈**。函数执行之后，上下文即被销毁，即**出栈**，销毁的过程中就会触发**垃圾回收**。

   因为作用域链有由内而外的，所以全局作用域是无法访问函数内部作用域变量的。但是，如果外部函数中返回了一个函数，这个函数提供一个了**执行上下文**，在这个上下文中引用其它上下文的变量对象时，垃圾回收监听这个引用（可达对象）还在，就不会进项回收。当你在当前执行环境中访问它时，它还是在内存当中的。

   这就是**闭包**的基本原理。

10. Promise链式调用，如果第一个then返回的结果是数字或者函数，后面的then返回什么？

11. Promise 中的三兄弟 .all(), .race(), .allSettled()分贝代表什么含义？

12. 对 async/await 的理解，分析内部原理

    Promise解决了回调地狱的问题，但是如果遇到复杂的业务，代码里面会包含大量的 then 函数，使得代码依然不是太容易阅读。基于这个原因，ES7 引入了 async/await，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰，而且还支持 try-catch 来捕获异常，非常符合人的线性思维。

    async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。是Generator函数的语法糖，并对Generator函数进行了改进，彻底告别**执行器和生成器**，实现更加直观简洁的代码。

    它的重点是自带了执行器，相当于把我们要额外做的(写执行器/依赖co模块)都封装了在内部。

    ```js
    function getNum(num){
    	return new Promise((resolve, reject) => {
      	setTimeout(() => {
        	resolve(num+1)
      	}, 1000)
      })
    }
    
    //自动执行器,如果一个Generator函数没有执行完,则递归调用
    function asyncFun(func){
      var gen = func()
    
      function next(data){
        var result = gen.next(data);
        if (result.done) return result.value;
        result.value.then(function(data){
        next(data)
        })
      }
    
      next()
    }
    
    // 所需要执行的Generator函数,内部的数据在执行完成一步的promise之后,再调用下一步
    var func = function* (){
      var f1 = yield getNum(1)
      var f2 = yield getNum(f1)
      console.log(f2)
    }
    asyncFun(func)
    ```

13. 若 `a=1，b=2 表达式`a+++b`的返回结果是什么？引擎是如何解析的

    结果为3，++运算符的优先级高于+运算符，所以先执行a++得到1，然后1+b=3

14. 遍历数组的方式有哪些？

15. 防抖和节流的区别是什么？实现原理是怎样的？

16. 事件传播是怎么回事？

17. offsetTop是元素相对于哪里的距离？

18. Proxy和Object.defineProperty的区别？

    - Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性 
    - 如果对象内部要全部递归代理，则Proxy可以只在调用时递归，而Object.defineProperty需要在一开始就全部递归，Proxy性能优于Object.defineProperty
    - Proxy 可以**监视**读写以外的操作，比如deleteProperty方法监听删除
    - Proxy 可以很方便的监视数组操作，因为set有target, property, value三个入参
    - Proxy 不需要侵入对象
    - Proxy不兼容IE，Object.defineProperty不兼容IE8及以下

## Ts

1. 你觉得 TypeScript 和 JavaScript 有什么区别

   Javascript是一个动态类型且弱类型的语言，早前的js应用简单，没有编译环节。但是在大规模应用中，弱类型的优势就变成了短板，比如使用了对象上不存在的属性/方法、实参和形参类型不匹配，造成函数功能发生改变、隐式转换导致使用时的错误用法

   TS是JS的超集，TS在JS的基础上添加类型系统以及完全的支持ES6+语法，TS需要编译，最低可以编译到ES3版本，JS基本直接被浏览器解析执行。使用Ts的优势是错误更早暴露、代码更智能，编码更准确、重构更牢靠、减少不必要的类型判断

   **TS的缺点**：语言本身多了很多概念（类，接口，枚举，泛型）等，学习成本高，但是好在ts是渐进式的，可以向下兼容不适合中小型项目，Ts会增加一些成本

2. ts新增了哪些数据类型？

   - 元组(Tuple)：数组的拓展，表示已知元素数量和类型的数组
   - 枚举(enum)：定义一组角色，每一个角色用一个数字代表,从0开始编号。
   - any: 任意的,不清楚类型的变量类型，可以可以用来兼容老项目，但是存在类型安全问题，不要滥用
   - void：没有任何类型，用来定义没有返回值的函数，void类型的变量只能赋值给undefined和null，其他类型不能赋值给void类型的变量
   - never：永不存在的值的类型，是任何类型的子类型，除它自身外的任何类型都不能赋值给never类型

3. enum 和 const enum 的区别是什么？

   枚举类型会入侵到运行时代码, 编译结果会编译成一个双向的键值对对象，如果不需要通过索引器访问属性值，就在enum前加上const。数值枚举存在索引递增机制，如果给其中属性默认值，下面的其它属性值会累加。

4. 装饰器的实现原理及应用场景？

   decorator使得在运行时注释和修改类和属性成为可能。

5. interface和type的区别？

   相同点：都可以定义一个对象或函数

   区别

   1. type 可以声明基本类型别名，联合类型，元组等类型，interface不能
   2. type 语句中可以使用操作符 typeof & keyof，interface不能
   3. interface 能够声明合并，type不能
   4. interface 可以使用 extends 关键字，type不可以

# 进阶

## 工程化

1. 如何理解前端工程化？

   前端工程化的主要目的为了**提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间**。前端工程化需要从四点做起：模块化，组件化，规范化和自动化

   - 模块化：将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载
   - 组件化：将UI页面拆分成由**模板html+样式css+逻辑js**组成的功能单元，称为组件。组件化不等于模块化，模块化是在资源和代码方面对文件的拆分，而组件化是在UI层面进行的拆分。
   - 规范化：js规范，css规范，前后端接口规范，命名规范，git规范，这都会大大提升开发效率。
   - 自动化：让简单重复的工作交给机器完成，例如自动化测试，自动化部署，自动化构建，持续集成等。

2. 模块化规范：CMD，AMD，CommonJS，ESM的区别？

   - AMD：通过模拟script标签的方式实现模块定义和使用，支持js动态导入。AMD的**define方法**有三个入参—模块名称、依赖模块、模块定义函数，通过`return`方式导出成员。**Require.js**实现了AMD规范。
   - CMD规范：与AMD规范的原理是一样的，CMD的define方法只有一个入参—模块定义函数，通过`exports`或`module.exports`方式导出成员。**Sea.js**实现了CMD规范。
   - CommonJS规范：一个文件就是一个模块，每个模块都有单独的作用域，通过module.exports导出成员，通过require函数载入模块。**NodeJS**实现了CommonJS规范。
   - ES Modules规范：ECMAScript中定义的一套最新的模块系统，设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6定义了ESM规范。
   
      **对比**
   
   1. AMD和CMD在定义模块上有区别，AMD提供了模块依赖注入和控制反转功能，CMD没有这功能，导出方式类似于CommonJs。
   2. ESM在编译时确定模块的依赖关系，编译时加载（静态加载）模块；AMD/CMD和CommonJs是在运行时确定依赖关系，运行时加载模块。
   3. CommonJs是同步模式加载模块，加载过程阻塞代码执行；AMD/CMD和ESM是异步模式加载模块，有一个独立的模块依赖的解析阶段。
   4. ESM可以做tree-shaking

3. Babel是如何编译代码的

   Babel编译的核心原理是**使用AST抽象语法树对源码进行分析并转为目标代码**。

   - 通过IIFE立即执行函数实现块级作用域，给块内的变量重新命名
   - 对const声明的变量，只要检测到变量二次赋值，就会通过只读函数抛出错误
   - 对于for循环中let声明的变量，Babel使用闭包保存每一个循环变量i的值
   - 对于箭头函数的转换，就是将当前环境下的this存储起来，在函数内调用
   - 对于async的转换，

4. package.lock.json的作用是什么？

5. webpack打包的过程？

   - 根据`entry`找到打包入口文件，根据`import，require`等推断依赖资源模块，解析出依赖关系树
   - 递归依赖树，找到每个节点对应的资源文件
   - 资源文件根据`moudles.rules`找到`loader`(文件加载器)，通过loader加载对应的资源模块
   - 最后将加载结果打包成bundle.js

6. tree-shaking的原理是什么？

   摇树，摇掉代码中未引用部分（dead-code），tree shaking 不是指某个配置选项,是一组功能搭配使用后的优化效果。它的前提是ES Modules，由webpack 打包的代码必须使用ESM方式实现模块化。

   对`tree-shaking`的检测：通过 `package.json` 的 `sideEffects` 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。

   optimization配置：

   - `usedExports:true`：用来标记未引用代码，打包结果中只会导出被使用的成员
   - `minimize:true`：开启代码压缩用来删除未被使用成员

7. webpack中hash有几种配置方式？

   当我们部署前端的资源文件时，都会启用服务器的静态资源缓存，这样浏览器客户端就可以缓存静态资源，提升响应速度。但是如何缓存过期时间设置的特别短没有效果，过长不能及时更新。为了解决这个问题，webpack在生产模式下给文件名添加hash值的方式，一旦资源发生改变，文件名称也可以跟着一起变化。对于客户端而言，全新的文件名就是全新的请求，就没有缓存的问题。

   - 项目级别—hash：`[name]-[hash].bundle.css`，任何改动全部重新生成
   - 模块级别—chunkhash：`[name]-[chunkhash].bundle.css`，只会重新生成代码模块对应chunk的文件
   - 文件级别—contenthash：`[name]-[content].bundle`，只会重新代码生成对应的文件，比如更新js不会更新css

8. webpack中loader和plugin的区别？

   loader：文件加载器，加载资源的过程类似于工作管道，只是单纯的文件转换过程，将所有的资源以及依赖转换为js模块并加载。

   plugin：扩展器，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于钩子事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。

9. 有没有自定义过plugin和loader？

   自定义loader

   - 实现：导出一个；函数，负责处理加载的资源，输入是资源文件的内容，输出是加工后的结果（必须是js代码）
   - 使用：在webpack.config.js中，将loader文件路径配置到module.rules.use上

   自定义plugin：通过**在生命周期的钩子函数中挂载函数实现扩展**。首先返回一个函数或者包含`apply`方法的对象，apply接收一个`compiler`对象作为参数，compiler有很多钩子函数，比如emit是在输出文件之前执行，钩子函数的入参`compilation`为此次打包的执行上下文。

10. 前端工程化中各个工具的区别

   1. webpack更适合开发应用程序，rollup更适合开发一个框架或者类库。
   2. rollup只是一个**ESM的打包器**，会自动开启**tree shaking**，插件是Rollup唯一的扩展途径 ，模块最终都被打包到一个函数中，无法实现HMR模块热替换。
   3. gulp强调的是开发的工作流程，是基于流的自动化构建工具。webpack强调的是模块化开发，是一个模块化打包工具
   4. grunt构建过程是基于临时文件实现的，所以构建速度相对较慢。gulp的构建过程是基于内存实现的，对文件处理环节都是在内存中完成的，相对于磁盘读写速度更快一些。

11. webpack如何做优化？应用场景有哪些？

12. CI/CD是什么？前端怎么实现CI/CD？

13. 如何实现前端代码的规范化？

    eslint，stylelint，html

    辅助工具：git hook，hasky

14. css中scope和deep的原理

15. wepack如何配置资源的cdn路径

## Vue

1. vue的生命周期？vue源码中属性和方法哪一个先初始化？
2. vue双向绑定的原理？
3. vue中如何操作数组？
4. vuex的使用场景？数据存储如何划分？
5. 什么是单向数据流？
6. vue计算属性的机制，以及使用场景？
7. 封装过哪些组件库？vue组件通信的方式。
8. vue3新增了哪些API？

## 跨端开发

1. h5和小程序的区别？

   小程序最终会编译成html标签在webView中渲染，h5渲染和js在一个进程中，小程序不是，原因是为了管控js，用数据驱动视图，解决业务的问题，只能用小程序本身定义的基础组件和交互。

   H5是一个在线的，小程序只能打包后提交给平台审核。

## 前端监控

1. 前端监控解决了什么问题？

   1）数据上报：运营行为监控，帮助运营和公司做出战略或战术上的决策

   2）错误监控：帮助开发人员做异常监控（window.onerror监听，uncaught事件）

   3）性能监控：监控前端的性能问题，比如首屏加载时间，第一个元素的出现速度，页面加载完成时间等

2. 前端监控的常见指标有哪些？

   - pv页面访问量：页面被访问多少次
     - 位置：被访问的地域（ip地址）
     - 用户信息：脱敏信息，通过登录账户来确定
     - 加载时间：监听页面开始加载到离开的时间，来决定页面优化（unload和beforeunload）
   - uv用户访问量：被多少个用户访问，比如新老用户访问，可以设计招新或留存的营销策略
   - 曝光量：区块出现在可见范围内的次数
     - 首屏曝光：对比pv是否相同，用户是否真的访问这个区块
     - 非首屏曝光
   - 点击量：按钮、链接、区块被点击的次数

   有了这些指标可以评估页面的价值以及未来的优化策略，ABtest：对于两个方案所有指标测试的评估结果
   
3. 什么是埋点？

   埋点就是在页面中写一些脚本，当用户操作页面的时候，记录一些信息。包含四个维度标识：站点site-页面page-区块block-按钮element。阿里的一些产品中叫SPM，super postion model

   - 手动埋点：操作js，logExpose曝光，logPV页面访问量，logClick点击量。缺点是对业务逻辑是有侵入的，但是灵活性高。
   - 自动埋点：添加div，动态识别dom元素，例如封装元素出现的组件。
   
4. 如何捕获框架级别的错误？



# 产品

**RPA**

1. RPA背后有哪些场景？
   - 从服务大型企业和中小型企业角度
   - 不同行业务场景不同
2. RPA这个产品最大的挑战是什么？
3. 你在RPA这个项目遇到的最难的问题是什么？怎么解决的？指令系统

**监控**

1. 监控系统数据量大的问题现在有什么更好的解决方案？
2. 监控系统解决了什么业务问题？
3. 是不是真的有解决问题？如果没有，还缺什么？
4. 当时整个系统有什么技术难点？系统拆分的原则，架构？

**权限系统**

1. 哪几种类型的权限系统？分别解决什么问题？解决方案？
2. 权限的定义，技术和产品分别怎么定义的？
3. 这个项目现在还存在哪些问题？你会怎样去解决？



